<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Mikel Mcdaniel">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Source Code highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <!-- MathJax -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <!-- Bootstrap core plus theme -->
  <link href="https://mikelmcdaniel.github.io/static/css/bootstrap_5.1.3_cutomized.css" rel="stylesheet" />
  <title>BrainFuck Instruction Finder</title>
  <style>
    @media print {
      .do-not-print {
        display: none;
        position: fixed;
        top: 0;
        visibility: hidden;
      }
    }
  </style>
</head>
<body>
<!-- Navigation-->
<nav class="do-not-print navbar navbar-expand-lg navbar-light" id="mainNav">
  <div class="container px-4 px-lg-5">
    <a class="navbar-brand" href="https://mikelmcdaniel.github.io/">Home</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ms-auto py-4 py-lg-0">
        <li class="nav-item"><a href="https://mikelmcdaniel.github.io/blog" class="nav-link px-lg-3 py-3 py-lg-4">Blog</a></li>
        <li class="nav-item"><a href="https://github.com/mikelmcdaniel" class="nav-link px-lg-3 py-3 py-lg-4">GitHub</a></li>
        <li class="nav-item"><a href="https://www.linkedin.com/in/mikel-mcdaniel-14ba74164/" class="nav-link px-lg-3 py-3 py-lg-4">LinkedIn</a></li>
        <li class="nav-item"><a href="https://mikelmcdaniel.github.io/resume" class="nav-link px-lg-3 py-3 py-lg-4">Résumé</a></li>
      </ul>
    </div>
  </div>
</nav>
<!-- Page Header-->
<header class="do-not-print masthead" style="background-image: url('https://mikelmcdaniel.github.io/static/imgs/code-background.png') ">
  <div class="container position-relative px-4 px-lg-5">
    <div class="row gx-4 gx-lg-5 justify-content-center">
      <div class="col-md-10 col-lg-8 col-xl-7">
        <div class="site-heading">
          <h1>BrainFuck Instruction Finder</h1>
          <span class="subheading">Searching through trillions of code snippets in minutes</span>
        </div>
      </div>
    </div>
  </div>
</header>

<section class="px-3">
  
<p>This is a post about... writing code to generate BF code that can do any computation... and my goal is to make this post as short and understandable as possible, regardless of your background in math or computers. Some things will be oversimplified for the sake of making it easier to understand.</p>
<p>If you've ever written BF code, then you know its hard to do anything but the most simple tasks with it. Its like having a machine that can assemble atoms together and using it to make an omelet. My idea of a good time.</p>
<h2>What is BF?</h2>
<p>First and foremost, its a way for me to avoid saying BrainFuck because I need you to know that I'm a serious professional and adult who doesn't say F*** too much. I'll refer to it as BF from now on.</p>
<p>If you're already familiar with BF, you can safely skip this section.</p>
<p>Secondly, BF is a very simple programming language that consists of just 8 instructions. The <a href="https://en.wikipedia.org/wiki/Brainfuck">BF Wikipedia article</a>. If you're familiar with Turing machines, BF programs get pretty close and, like a Turing machine, can perform any computation a regular computer can... if you're willing to wait long enough <em>and</em> have enough memory.</p>
<p>BF programs are text-based programs. They can't display pictures and buttons; they can read text you type in (one character at a time) and they can print out text (one character at a time).</p>
<h3>How does BF code work?</h3>
<p>A byte can represent any whole number between 0 and 255. Some numbers are used to represent characters, for example the numbers 48, 65, and 97 represent <code>'0'</code>, <code>'A'</code>, and <code>'a'</code> respectively. As a very nice convenience, the other digits and letters like <code>'1'</code>, <code>'B'</code>, and <code>'c'</code> all have numbers that are just 1, 2, and 3 more than <code>'0'</code>, <code>'A'</code>, and <code>'a'</code>. So... if you wanted to know what number represents <code>'h'</code>, its 97 + 7 = 104.</p>
<h4>Saying "hello" / The first 3 instructions</h4>
<p>When a BF program starts, all bytes it has access to are set to 0 <strong>and</strong> the program starts out only operating on just the 1st byte. Lets say that we wanted to print out "hello". First we have to get our byte from the value 0 to the value 104 so we can print out the "H". We do that with the increment instruction, <code>+</code>, which just adds 1 to our current byte. To get from 0 to 104, we need to repeat <code>+</code> 104 times.</p>
<pre><code>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
</code></pre>
<p>Before the code ran, the bytes in memory looked like [0, 0, 0, ...] but after, they contain [104, 0, 0, ...]</p>
<p>Now we can output our byte using the <code>.</code> instruction.</p>
<pre><code>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.
</code></pre>
<p>Outputs:</p>
<pre><code>h
</code></pre>
<p>Great! Now we just need to output the remaining letters "ello", which are represented with 101, 108, 108, and 111. To go from 104 to 101, we use the decrement instruction, <code>-</code>,  which subtracts 1 from the current byte. Note that the increment and decrement instructions wrap-around, meaning that incrementing a 255 byte sets it to 0 and decrementing a 0 byte sets is to 255.</p>
<p>Note also that the <code>+</code>s being on the first line and <code>.</code> on the second line is just to make the program easier to read. Any characters in a BF program that are not an instruction, are simply ignored by the BF program.</p>
<pre><code>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.
---
.
</code></pre>
<p>Outputs:</p>
<pre><code>he
</code></pre>
<p>Now we can finish the rest of the "hello" program!</p>
<pre><code>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.
---
.
+++++++
.
.
+++
.
</code></pre>
<p>Outputs:</p>
<pre><code>hello
</code></pre>
<h4>A useless calculator / The rest of the instructions</h4>
<p>Now, lets say we want to write a program that reads 2 digits for the user, then outputs their sum. Something like this:</p>
<pre><code>Digits to add: 23
2+3=5
</code></pre>
<p>First, we print "Digits to add: "</p>
<pre><code>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ .
+++++++++++++++++++++++++++++++++++++ .
-- .
++ .
+++++++++++ .
- .
----------------------------------------------------------------------------------- .
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ .
----- .
------------------------------------------------------------------------------- .
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ .
+++ .
 .
------------------------------------------ .
-------------------------- .
</code></pre>
<p>Once the code above has run, our memory contains the value of the last character printed and a lot of 0's: [32, 0, 0, ...].</p>
<p>Next, we read the 1st digit using the read instruction, <code>,</code>. This instruction will read a single character ant set the current byte to that value. In our example, the user enters <code>2</code> so the byte will have the value 50 = 48 + 2. Our memory looks like [50, 0, 0, ...]</p>
<p>After that, we need to read the next digit... into a different byte. For that, we use the <code>&gt;</code> instruction to go one byte to the right, then read into that byte via <code>,</code>. Once we've done that, the memory contains [50, 51, 0, 0, 0, ...]</p>
<p>Excellent! Now we can print out the <code>2+3=</code> one character at a time</p>
<ul>
<li>print out the 1st byte in memory</li>
<li>print out the '+'</li>
<li>go to the 3rd byte in memory</li>
<li>increment by the ASCII value for '+' (43)</li>
<li>print that byte</li>
<li>print out the 2nd byte in memory</li>
<li>print out the '='</li>
<li>go to the 3rd byte in memory</li>
<li>increment by difference in ASCII value for '=' (61) minus the ASCII value for '+' (61 - 43 = 18)</li>
<li>print that byte</li>
</ul>
<pre><code>&lt;.
&gt;&gt; +++++++++++++++++++++++++++++++++++++++++++ .
&lt;.
&gt; ++++++++++++++++++ .
</code></pre>
<p>Our next step is to calculate the digit we want to print. We're so close! Right now our first 2 bytes in memory have the ASCII value for the digits we want to add and what we need to compute is the ASCII value of the resulting digit. (Note: We're not going to worry about the digits adding up to more than <code>9</code> for now...)</p>
<p>For that we'll need the loop instructions, <code>[</code> which starts a loop and <code>]</code> which ends a loop. <code>[</code> will skip to the corresponding <code>]</code> instruction if the current byte is 0, otherwise the program will just run whatever code is between the <code>[</code> and <code>]</code>. Let's take some time to understand loops before we use them: The <code>]</code> will jump backwards to the corresponding <code>[</code>. The simplest loop you can write is just <code>[]</code> which will either loop infinitely or do nothing. Perhaps the next simplest loop you can write is <code>[-]</code> which will decrement the current byte until its 0 <em>or</em> maybe the next simplest loop is <code>[&gt;]</code> which will go to the next byte in memory that is 0.</p>
<p>Ok, now coming back to our task, the first 2 bytes in memory contain the ASCII values of the digits we want to add, e.g. 50 and 51. We want to calculate the ASCII value for the sum of those digits, e.g. 50-48 + 51-48 + 48 = 53. First, lets subtract 48 from both bytes in memory.</p>
<pre><code>&lt;&lt; ------------------------------------------------
&gt; ------------------------------------------------
</code></pre>
<p>Now memory looks like [2, 3, 0, 0, 0, ...].</p>
<p>Lastly, we can loop on the 2nd byte, which we'll call <code>memory[1]</code> and decrement by 1 then increment the first byte, <code>memory[0]</code>, by 1. Since the loop will execute that code until <code>memory[1]</code> is 0, it will run 3 times (or more or less if the user entered a different digit).</p>
<pre><code>[-&lt;+&gt;]
</code></pre>
<p>Now the memory looks like [5, 0, 0, 0, 0, ...].</p>
<p>Finally, we add 48 back to <code>memory[0]</code> and print it!</p>
<pre><code>&lt; ++++++++++++++++++++++++++++++++++++++++++++++++ .
</code></pre>
<p>Combining that all together, here's our full BF program:</p>
<pre><code>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ .
+++++++++++++++++++++++++++++++++++++ .
-- .
++ .
+++++++++++ .
- .
----------------------------------------------------------------------------------- .
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ .
----- .
------------------------------------------------------------------------------- .
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ .
+++ .
 .
------------------------------------------ .
-------------------------- .

,
&gt;,

&lt;.
&gt;&gt; +++++++++++++++++++++++++++++++++++++++++++ .
&lt;.
&gt; ++++++++++++++++++ .

&lt;&lt; ------------------------------------------------
&gt; ------------------------------------------------

[-&lt;+&gt;]

&lt; ++++++++++++++++++++++++++++++++++++++++++++++++ .
</code></pre>
<p>If the user enters "23", then the program outputs:</p>
<pre><code>Digits to add: 23
2+3=5
</code></pre>
<p>If the user enters "63", then the program outputs:</p>
<pre><code>Digits to add: 63
6+3=9
</code></pre>
<p>If the user enters "99", then the program outputs:</p>
<pre><code>Digits to add: 99
9+9=B
</code></pre>
<p>Perfection.</p>
<h2>Motivation</h2>
<p>Writing BF directly is quite hard, so to make it a little easier, I wanted to write code that finds/generates snippets of BF code to do an arbitrary computation.</p>
<p>For example, that we wanted to update our calculator app so that it prints "9+9=18" instead of "9+9=B". To do that, we need to be able to compute things like 'is x &gt; 10?', 'x / 10', and 'x modulo 10' where x is one of the bytes in <code>memory</code>.</p>
<h2>Where to Start</h2>
<h3>Too many BF programs to check</h3>
<p>At this point, I already knew the BF code <code>[-&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;[-&lt;+&gt;&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;]&lt;[-]</code> replaces <code>memory[0]</code> with <code>memory[0] * memory[1]</code> and sets <code>memory[1]</code> to 0. And that program is 40 instructions total, so to generate BF code that does something more complicated than multiplication, it probably needs to be able to find/generate code snippets that are around 40 instructions or more.</p>
<p>Since we're just performing computations without taking performing input or output, there are 6 instructions available. Each <code>[</code> must be paired with a <code>]</code> instruction so the number of BF programs with exactly 40 instructions is <strong>less</strong> than 5^40 = 9,094,947,017,729,282,379,150,390,625... which would only take about 5^40 / (365.25 * 24 * 60 * 60 * 4,000,000,000 * 1,000,000,000) ~= 72 years if we can check each program in 1 clock cycle on a billion 4GHz CPU cores. If you include checking all the programs that are less than 40 instructions, it only adds about 18 more years, but if you check up to 41 instruction, it takes centuries.</p>
<h3>Identical BF snippets and Registers</h3>
<p>While there may be many BF programs, most of them are probably performing the same calculation. All the following snippets just set the current byte to 1 without modifying any other bytes: <code>[[-]]+</code>, <code>[--+]+</code>, <code>[-]--&lt;&gt;+++</code>, <code>[+]++-</code>.</p>
<p>We also just want to compute simple things like <code>memory[0] * memory[1]</code> or <code>memory[0] / memory[1]</code> or <code>memory[0] &lt;= memory[1]</code>. All of these calculations take 2 bytes as input and have 1 byte as output. We might want to have more inputs or outputs but lets just stick with 2 inputs and 1 output for now.</p>
<p>At this point, there are many possible programs but also many duplicate programs.</p>
<h4>Using registers</h4>
<p>We can simplify our problem a bit by removing the <code>&gt;</code> and <code>&lt;</code> instructions and adding in an "index" or "register" that each instruction applies to. For example, instead of writing <code>[-]</code>, we could write <code>[0 -0 ]0</code> to say that the loop-start, decrement, and loop-end instructions all happen on <code>memory[0]</code>. This can help us skip bits of code that contains <code>&gt;&lt;</code> or <code>&lt;&gt;</code> <strong>and</strong> helps us just focus on BF snippets that access a limited amount of memory (which will be useful for other reasons later).</p>
<p>Rewriting BF <code>[-&gt;+&lt;]</code> to RBF (Register BF), we have <code>[0 -0 +1 ]0</code>. Similarly, rewriting our BF for multiplication <code>[-&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;[-&lt;+&gt;&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;]&lt;[-]</code>, we get <code>[0 -0 +2 ]0 [2 -2 [1 -1 +0 +3 ]1 [3 -3 +1 ]3 ]2 [1 -1 ]1</code>. Note that when we use R registers, then the number of instructions is 4 * R.</p>
<p>Now the total number of programs of length 40 instructions is dependent on the number of registers (i.e. bytes in memory) that we use. For multiplication, we needed 4 registers and we used 19 RBF instructions. To simplify again, we can pretend there's only 1 type of loop instruction to get a lower bound on the number of programs that are "similarly complex" to our multiplication program: (3 * 4) ^ 19 = 319,479,999,370,622,926,848. <strong>That's already 2.8 billion times less than our BF estimate, though it's still quite large.</strong></p>
<h3>Simplifying to 2 inputs + 1 output isn't enough</h3>
<p>So how many "unique" BF programs can there be that take 2 bytes as input and output 1 byte? There are 256^2 = 65,536 possible inputs and each of those inputs could have 256 different outputs <em>xor</em> the program can infinite loop. That's (256 + 1)^(256^2) = ... a rather large number with log(257, 10) * 256^2 ~= 157,938 digits.</p>
<p>Well... ok.</p>
<h3>What if bytes were smol?</h3>
<p>Do we really need 256 values when we're looking for instructions? There's nothing about <code>[-&gt;+&lt;]</code> that <em>really</em> depends on the number of values each byte or "cell" can hold. The same thing is true for the BF multiplication code. If we ran it on a BF machine where each cell could only go up to 10 instead of 256, the code would work essentially the same as it does now.</p>
<p>So how many unique BF programs can there be that take 2 cells as input and output 1 cell? If each cell can represent any whole number from 0 to M - 1: There are M^2 possible inputs and each of those inputs could have M different outputs <em>xor</em> infinite loop. That's (M + 1)^(M^2) total unique simple programs.</p>
<table>
<thead>
<tr>
<th>M</th>
<th>(M + 1)^(M^2)</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>81</td>
</tr>
<tr>
<td>3</td>
<td>262,144</td>
</tr>
<tr>
<td>4</td>
<td>152,587,890,625</td>
</tr>
<tr>
<td>5</td>
<td>2.84303E+19</td>
</tr>
<tr>
<td>6</td>
<td>2.65173E+30</td>
</tr>
<tr>
<td>7</td>
<td>1.78406E+44</td>
</tr>
<tr>
<td>8</td>
<td>1.17902E+61</td>
</tr>
<tr>
<td>9</td>
<td>1E+81</td>
</tr>
<tr>
<td>10</td>
<td>1.37806E+104</td>
</tr>
<tr>
<td>11</td>
<td>3.81005E+130</td>
</tr>
<tr>
<td>12</td>
<td>2.55766E+160</td>
</tr>
<tr>
<td>13</td>
<td>4.96179E+193</td>
</tr>
<tr>
<td>14</td>
<td>3.26503E+230</td>
</tr>
<tr>
<td>15</td>
<td>8.45271E+270</td>
</tr>
</tbody>
</table>
<p>Now we're talking! There's only 1 potential issue: We might need more than just 2 registers. The RBF multiplication code used 4 registers though... it assumed registers 2 and 3 started at 0 and when the code was done running, registers 2 and 3 were back to 0. We'll come back to this later...</p>
<h2>Initial Attempt</h2>
<h3>Verifying when an RBF program works</h3>
<p>First, let's make sure we can detect when a program does what we want...</p>
<pre><code class="language-python">import dataclasses
import itertools
from typing import Literal


NUM_CELL_VALUES = 256
NUM_REGISTERS = 2
NUM_INPUT_REGISTERS = 2
NUM_OUTPUT_REGISTERS = 1


class RBFException(Exception):
    pass


class MismatchedBraces(RBFException):
    pass


class InvalidProgram(RBFException):
    pass


Instruction = tuple[Literal['+', '-', '[', ']'], int]


def get_matching_braces_dict(instructions: list[Instruction]) -&gt; dict[int, int]:
    matches = {}
    left_braces = []
    for ip, (op_code, register) in enumerate(instructions):
        if op_code == '[':
            left_braces.append((ip, register))
        elif op_code == ']':
            if not left_braces:
                raise MismatchedBraces(f'Missing left brace for right brace at {ip}: {instructions}')
            left_ip, left_register = left_braces.pop()
            if left_register != register:
                raise MismatchedBraces(
                    f'Left brace register {left_register} at {left_ip} does not match right brace register {register} '
                    f'at {ip}: {instructions}')
            matches[ip] = left_ip
            matches[left_ip] = ip
    if left_braces:
        raise MismatchedBraces(f'Missing right brace for left brace(s) at {left_braces}: {instructions}')
    return matches


@dataclasses.dataclass
class RBFProgram:
    instructions: list[Instruction]
    matching_braces: dict[int, int]

    def __init__(self, instructions: list[Instruction], matching_braces: dict[int, int]=None):
        if matching_braces is None:
            matching_braces = get_matching_braces_dict(instructions)
        for op_code, register in instructions:
            if op_code not in '+-[]' or register &lt; 0:
                raise InvalidProgram(str(instructions))
        self.instructions = instructions
        self.matching_braces = matching_braces

    def run(self, memory) -&gt; None:
        '''Run this RBF program on the memory. This WILL modify the memory.'''
        ip = 0  # instruction pointer
        while ip &lt; len(self.instructions):  # Once we've reached the end of our instructions, we're done!
            op_code, register = self.instructions[ip]
            if op_code == '+':
                memory[register] = (memory[register] + 1) % NUM_CELL_VALUES
                ip += 1
            elif op_code == '-':
                memory[register] = (memory[register] - 1) % NUM_CELL_VALUES
                ip += 1
            elif op_code == '[':
                if memory[register]:
                    ip += 1
                else:
                    ip = self.matching_braces[ip] + 1
            elif op_code == ']':
                ip = self.matching_braces[ip]

    @staticmethod
    def from_rbf_str(rbf_str: str) -&gt; 'RBFProgram':
        rbf_str = ''.join(c for c in rbf_str if c in '+-[]1234567890')
        # For now, we only support up to 10 registers
        instructions = [(op_code, int(register)) for op_code, register in zip(rbf_str[::2], rbf_str[1::2])]
        return RBFProgram(instructions)


# For now, we're trying to write a program that can find something &quot;as complex&quot; as multiplication, so we just check
# that the program can multiply 2 cells.
def program_works(program: RBFProgram) -&gt; bool:
    for a, b in itertools.product(range(NUM_CELL_VALUES), repeat=NUM_INPUT_REGISTERS):
        memory = [a, b, 0, 0]
        program.run(memory)
        if memory != [(a * b) % NUM_CELL_VALUES, 0, 0, 0]:
            return False
    return True


def main():
    multiplier = RBFProgram.from_rbf_str('[0 -0 +2 ]0 [2 -2 [1 -1 +0 +3 ]1 [3 -3 +1 ]3 ]2 [1 -1 ]1')
    assert program_works(multiplier)
    adder = RBFProgram.from_rbf_str('[1 -1 +0 ]1')
    assert not program_works(adder)


if __name__ == '__main__':
    main()
</code></pre>
<p>This works. However, it takes over a minute to run on my laptop.</p>
<h3>Speeding up how we interpret RBF</h3>
<p>I find RBF code harder to read. Let's focus take a look at the (BF version) of our multiplication program to see what can be sped up.</p>
<pre><code class="language-python">class RBFProgram:
    ...
    def as_bf_str(self, starting_register: int=0) -&gt; str:
        bf: list[str] = []
        cur_register = starting_register
        for op_code, next_register in self.instructions:
            bf.append((next_register - cur_register) * '&gt;')
            bf.append((cur_register - next_register) * '&lt;')
            bf.append(op_code)
            cur_register = next_register
        return ''.join(bf)

multiplier = RBFProgram.from_rbf_str('[0 -0 +2 ]0 [2 -2 [1 -1 +0 +3 ]1 [3 -3 +1 ]3 ]2 [1 -1 ]1')
print(multiplier.as_bf_str(2))

# Outputs:
# &lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;[-&lt;+&gt;&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;]&lt;[-]
</code></pre>
<h4>A new paradigm</h4>
<p>There are a few patterns, we can recognize:
- <code>[-]</code> Sets <code>memory[0]</code> to 0.
- <code>[-&gt;&gt;+&lt;&lt;]</code> Adds <code>memory[0]</code> to <code>memory[2]</code> and sets <code>memory[0]</code> to 0
- <code>[-&lt;+&gt;&gt;&gt;+&lt;&lt;]</code> Destructively adds one cell to two other cells</p>
<p>If we generalize these a bit, we consider BF like <code>[-&gt;--&gt;+++&lt;&lt;]</code> (and its equivalent RBF) that don't just add one cell to another <em>but instead</em> add one cell times some constant to another; <code>memory[1] -= 2 * memory[0]</code>, <code>memory[2] += 3 * memory[0]</code>, <code>memory[0] = 0</code>.</p>
<p>Instead of each <code>RBFProgram</code> being a single Python object where the instructions control everything, let's make <code>RBFProgram</code> that are specialized and delegate to each other. This will allow us to swap out pieces of the RBF program for more optimized versions.</p>
<p>Here's the new version of <code>RBFProgram</code> before we apply any optimizations:</p>
<pre><code class="language-python"># Note that no longer need get_matching_braces_dict

class RBFProgram:
    @abstractmethod
    def run(self, memory: list[int]) -&gt; None:
        raise NotImplementedError()

    @abstractmethod
    def instructions(self) -&gt; Iterator[Instruction]:
        raise NotImplementedError()

    def as_bf_str(self, starting_register: int=0) -&gt; str:
        bf: list[str] = []
        cur_register = starting_register
        for op_code, next_register in self.instructions():
            bf.append((next_register - cur_register) * '&gt;')
            bf.append((cur_register - next_register) * '&lt;')
            bf.append(op_code)
            cur_register = next_register
        return ''.join(bf)

    @staticmethod
    def from_rbf_str(rbf_str: str) -&gt; 'RBFProgram':
        rbf_str = ''.join(c for c in rbf_str if c in '+-[]1234567890')
        instructions = [(op_code, int(register)) for op_code, register in zip(rbf_str[::2], rbf_str[1::2])]

        programs: list[list['RBFProgram']] = [[]]
        for ip, (op_code, register) in enumerate(instructions):
            if op_code == '-':
                programs[-1].append(Increment(register, -1))
            elif op_code == '+':
                programs[-1].append(Increment(register, 1))
            elif op_code == '[':
                programs.append([])
            elif op_code == ']':
                if len(programs) &lt;= 1:
                    raise MismatchedBraces(f'Missing left brace for right brace at {ip}: {instructions}')
                inner_code = Progn.or_single_program(programs.pop())
                programs[-1].append(Loop(register, inner_code))
        if len(programs) != 1:
            raise MismatchedBraces(f'Missing right brace for left brace(s): {instructions}')
        return Progn.or_single_program(programs[0])



class Increment(RBFProgram):
    &quot;&quot;&quot;Increments a cell by ANY amount.&quot;&quot;&quot;
    def __init__(self, register: int, amount: int):
        self.register = register
        self.amount = amount

    def run(self, memory: list[int]) -&gt; None:
        memory[self.register] = (memory[self.register] + self.amount) % NUM_CELL_VALUES

    def instructions(self) -&gt; Iterator[Instruction]:
        for _ in range(self.amount):
            yield '+', self.register
        for _ in range(-self.amount):
            yield '-', self.register

    def __repr__(self):
        return f'Increment({self.register!r}, {self.amount!r})'


class Loop(RBFProgram):
    &quot;&quot;&quot;Loops until memory[self.register] != 0.&quot;&quot;&quot;
    def __init__(self, register: int, inner_code: RBFProgram):
        self.register = register
        self.inner_code = inner_code

    def run(self, memory: list[int]) -&gt; None:
        while memory[self.register]:
            self.inner_code.run(memory)

    def instructions(self) -&gt; Iterator[Instruction]:
        yield '[', self.register
        yield from self.inner_code.instructions()
        yield ']', self.register

    def __repr__(self):
        return f'Loop({self.register!r}, {self.inner_code!r})'


class Progn(RBFProgram):
    &quot;&quot;&quot;A series of RBFPrograms run in sequence.&quot;&quot;&quot;
    def __init__(self, programs: list[RBFProgram]):
        self.programs = programs

    def run(self, memory: list[int]) -&gt; None:
        for p in self.programs:
            p.run(memory)

    def instructions(self) -&gt; Iterator[Instruction]:
        for p in self.programs:
            yield from p.instructions()

    @staticmethod
    def or_single_program(programs: list[RBFProgram]) -&gt; RBFProgram:
        if len(programs) == 1:
            return programs[0]
        return Progn(programs)

    def __repr__(self):
        return f'Progn({self.programs!r})'

...

def main():
    adder = RBFProgram.from_rbf_str('[1 -1 +0 ]1')
    print(adder.as_bf_str(), '--&gt;', repr(adder))
    print()
    multiplier = RBFProgram.from_rbf_str('[0 -0 +2 ]0 [2 -2 [1 -1 +0 +3 ]1 [3 -3 +1 ]3 ]2 [1 -1 ]1')
    print(multiplier.as_bf_str(2), '--&gt;', repr(multiplier))
    print()

'''
Outputs:
&gt;[-&lt;+&gt;] --&gt; Loop(1, Progn([Increment(1, -1), Increment(0, 1)]))

&lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;[-&lt;+&gt;&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;]&lt;[-] --&gt; Progn([Loop(0, Progn([Increment(0, -1), Increment(2, 1)])), Loop(2, Progn([Increment(2, -1), Loop(1, Progn([Increment(1, -1), Increment(0, 1), Increment(3, 1)])), Loop(3, Progn([Increment(3, -1), Increment(1, 1)]))])), Loop(1, Increment(1, -1))])
'''
</code></pre>
<h4>DestructiveAdd</h4>
<p>Now, we can detect <code>Loop</code>s that only contain <code>Increment</code>s and replace them with a new DestructiveAdd class:</p>
<pre><code class="language-python">class DestructiveAdd(RBFProgram):
    &quot;&quot;&quot;An optimized version of [-], [-&gt;+&lt;], [+&gt;++&gt;---&lt;&lt;], etc.&quot;&quot;&quot;
    def __init__(self, source_register: int, targets_and_multipliers: list[tuple[int, int]]=None):
        if targets_and_multipliers is None:
            targets_and_multipliers = []
        self.source_register = source_register
        self.targets_and_multipliers = targets_and_multipliers

    def run(self, memory: list[int]) -&gt; None:
        source_amount = memory[self.source_register]
        for register, multiplier in self.targets_and_multipliers:
            memory[register] = (memory[register] + multiplier * source_amount) % NUM_CELL_VALUES
        memory[self.source_register] = 0

    def instructions(self) -&gt; Iterator[Instruction]:
        yield '[', self.source_register
        yield '-', self.source_register
        for register, multiplier in self.targets_and_multipliers:
            for _ in range(multiplier):
                yield '+', register
            for _ in range(-multiplier):
                yield '-', register
        yield ']', self.source_register

    def __repr__(self):
        return f'DestructiveAdd({self.source_register!r}, {self.targets_and_multipliers!r})'


def simplify_to_destructive_add(original_loop: Loop, increments: list[Increment]) -&gt; RBFProgram:
    source_increments = [i for i in increments if i.register == original_loop.register]
    source_amount = sum(i.amount for i in source_increments)
    if source_amount % NUM_CELL_VALUES == 0:
        raise InfiniteLoop()
    if math.gcd(source_amount, NUM_CELL_VALUES) != 1:
        # Anytime memory[source_register] is not a multiple of source_amount, this is an infinite loop!
        # We can't optimize this... easily
        return original_loop
    if source_amount != -1 and source_amount != 1:
        # TODO: Calculate the multiplicative inverse of source_amount modulo NUM_CELL_VALUES so we optimize!
        return original_loop
    multiplicative_inverse = -source_amount  # Only true if source_amount == -1 or 1
    targets_and_amounts = collections.defaultdict(int)
    for increment in increments:
        if increment.register != original_loop.register:
            targets_and_amounts[increment.register] += multiplicative_inverse * increment.amount
            if targets_and_amounts[increment.register] == 0:
                del targets_and_amounts[increment.register]
    return DestructiveAdd(original_loop.register, sorted(targets_and_amounts.items()))


def simplified_program(program: RBFProgram) -&gt; RBFProgram:
    if isinstance(program, Progn):
        inner_programs = [simplified_program(p) for p in program.programs]
        if len(inner_programs) == 1:
            return inner_programs[0]
        if all(simplified is original for simplified, original in zip(inner_programs, program.programs)):
            return program
        else:
            return Progn.or_single_program(inner_programs)
    elif isinstance(program, Loop):
        inner_code = simplified_program(program.inner_code)
        if isinstance(inner_code, Increment):
            return simplify_to_destructive_add(program, [inner_code])
        elif isinstance(inner_code, Progn) and all(isinstance(p, Increment) for p in inner_code.programs):
            return simplify_to_destructive_add(program, inner_code.programs)
        elif inner_code is not program.inner_code:
            return Loop(program.register, inner_code)
    # Note: We can perform a lot more optimizations, but we'll start here for now.
    return program

...

def main():
    multiplier = RBFProgram.from_rbf_str('[0 -0 +2 ]0 [2 -2 [1 -1 +0 +3 ]1 [3 -3 +1 ]3 ]2 [1 -1 ]1')
    print('Original multiplier:')
    print(multiplier.as_bf_str(2))
    print(repr(multiplier))
    print()

    print('Simplified multiplier:')
    multiplier = simplified_program(multiplier)
    print(multiplier.as_bf_str(2))
    print(repr(multiplier))
    print()

    assert program_works(multiplier)

    adder = RBFProgram.from_rbf_str('[1 -1 +0 ]1')
    print('Original adder:')
    print(adder.as_bf_str())
    print(repr(adder))
    print()

    adder = simplified_program(adder)
    print('Simplified adder:')
    print(adder.as_bf_str())
    print(repr(adder))
    print()

    assert not program_works(adder)

'''
Outputs:
Original multiplier:
&lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;[-&lt;+&gt;&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;]&lt;[-]
Progn([Loop(0, Progn([Increment(0, -1), Increment(2, 1)])), Loop(2, Progn([Increment(2, -1), Loop(1, Progn([Increment(1, -1), Increment(0, 1), Increment(3, 1)])), Loop(3, Progn([Increment(3, -1), Increment(1, 1)]))])), Loop(1, Increment(1, -1))])

Simplified multiplier:
&lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;[-&lt;+&gt;&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;]&lt;[-]
Progn([DestructiveAdd(0, [(2, 1)]), Loop(2, Progn([Increment(2, -1), DestructiveAdd(1, [(0, 1), (3, 1)]), DestructiveAdd(3, [(1, 1)])])), DestructiveAdd(1, [])])

Original adder:
&gt;[-&lt;+&gt;]
Loop(1, Progn([Increment(1, -1), Increment(0, 1)]))

Simplified adder:
&gt;[-&lt;+&gt;]
DestructiveAdd(1, [(0, 1)])

'''
</code></pre>
<p>Now the code runs much faster.</p>
<h2>Detecting infinite loops</h2>
<p>We know that when we generate code to evaluate, we will inevitably generate code loops infinitely. While some loops can be detected with static analysis, like the <code>raise InfiniteLoop()</code> in <code>simplify_to_destructive_add</code>, there will be infinite loops that we can only detect when we start running the program.</p>
<p>Let's walk through 3 strategies.</p>
<h3>1. Stop the program after N steps</h3>
<p>Since we know the maximum number of possible values that the memory can take on, We can let each loop of the program run for up to that many steps. Any loop that runs beyond that many steps must be looping infinitely.</p>
<p>For example: If <code>NUM_REGISTERS == 2</code> and <code>NUM_CELL_VALUES == 10</code>, then we know that any loop can loop at most <code>NUM_CELL_VALUES</code>^<code>NUM_REGISTERS</code> = 100 times <strong>unless</strong> its an infinite loop!</p>
<pre><code class="language-python">class Loop(RBFProgram):
    ...

    def run(self, memory: list[int]) -&gt; None:
        max_iterations = NUM_CELL_VALUES**NUM_REGISTERS
        num_iterations = 0
        while memory[self.register]:
            self.inner_code.run(memory)
            num_iterations += 1
            if num_iterations &gt; max_iterations:
                raise InfiniteLoop()
</code></pre>
<p>Unfortunately this doesn't work when you have nested loops. If each loop is allowed to run <code>100</code> times and you have K nested loops, you quickly get to a billion steps for just one program.</p>
<p>Another reason this approach doesn't work is that we need to detect infinite loops faster so we don't spend a lot of time running RBF with infinite loops in it.</p>
<h3>2. Keep track of the memory you've seen before</h3>
<p>The idea here is very similar to '1. Stop the program after N steps'. Instead of keeping track of how many times each loop has run, each loop keeps track of which "memories" its seen before.</p>
<pre><code class="language-python">
class Loop(RBFProgram):
    ...

    def run(self, memory: list[int]) -&gt; None:
        past_memories = set()
        while memory[self.register]:
            self.inner_code.run(memory)
            cur_memory = tuple(memory)
            if cur_memory in past_memories:
                raise InfiniteLoop()
            past_memories.add(cur_memory)
</code></pre>
<p>This will only run the loop <em>until</em> the memory ends up in a state we've seen before. The good news is we will detect infinite loops much sooner. The bad news is that it will use more memory and will run slower since it has to take snapshots of the memory and constantly check if we've seen that memory state before.</p>
<h3>3. Fast and Slow</h3>
<p>If you've ever heard of the "fast and slow pointers" solution to detecting loops and linked lists, then this approach will look very familiar to you.</p>
<p>I think it's easiest to imagine 2 runners racing on a trail through a forest. The runners don't know if the trail loops back on itself. One runner is twice as fast as the other runner. The runners start running at the same time from the same spot. If there's no infinite loop in the trail, then the runners will never see each other... <strong>but</strong> if there is an infinite loop, then the fast runner will eventually see the slow runner again.</p>
<pre><code class="language-python">class Loop(RBFProgram):
    ...

    def run(self, memory: list[int]) -&gt; None:
        fast_memory = memory
        slow_memory = list(memory)  # Copy the memory

        while fast_memory[self.register]:
            self.inner_code.run(fast_memory)
            if fast_memory == slow_memory:
                raise InfiniteLoop()

            if not fast_memory[self.register]:
                break

            self.inner_code.run(fast_memory)
            # Note: Since fast_memory[self.register] has always been non-zero,
            #        then slow_memory[self.register] has always been non-zero.
            self.inner_code.run(slow_memory)
            if fast_memory == slow_memory:
                raise InfiniteLoop()
</code></pre>
<h3>Which is best?</h3>
<p>Probably option 3 but... it depends.</p>
<p>Let's say that K is the number of (nested) loops in the RBF and L is the length of the infinite loop <em>before</em> it starts repeating, then the memory and time big-O tradeoffs <em>probably</em> look something like this:</p>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Memory</th>
<th>Runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td>Don't detect infinite loops</td>
<td>O(1)</td>
<td>O(infinity)</td>
</tr>
<tr>
<td>Run N steps</td>
<td>O(1)</td>
<td>O((NUM_REGISTERS^NUM_CELL_VALUES)^K)</td>
</tr>
<tr>
<td>Keep track of past memory states</td>
<td>O(K * L)</td>
<td>O(L^K)</td>
</tr>
<tr>
<td>Fast and Slow</td>
<td>O(K)</td>
<td>O(L^K)</td>
</tr>
</tbody>
</table>
<p>Big-O is not the only thing that matters, so it's a good idea to try out different strategies, especially since options 2 and 3 are harder to distinguish!</p>
<h2>Generating programs to check</h2>
<h3>The simple way (doesn't work)</h3>
<p>The simplest strategy would be to try building the programs up one instruction at a time. Something like this:</p>
<pre><code class="language-python">...

class MismatchedBraces(RBFException):
    pass

class MissingLeftBrace(MismatchedBraces):
    pass

class MissingRightBrace(MismatchedBraces):
    pass

...

class RBFProgram:
    ...

    @staticmethod
    def from_instructions(instructions: list[Instruction]) -&gt; 'RBFProgram':
        programs: list[list['RBFProgram']] = [[]]
        for ip, (op_code, register) in enumerate(instructions):
            if op_code == '-':
                programs[-1].append(Increment(register, -1))
            elif op_code == '+':
                programs[-1].append(Increment(register, 1))
            elif op_code == '[':
                programs.append([])
            elif op_code == ']':
                if len(programs) &lt;= 1:
                    raise MissingLeftBrace(f'Missing left brace for right brace at {ip}: {instructions}')
                inner_code = Progn.or_single_program(programs.pop())
                programs[-1].append(Loop(register, inner_code))
        if len(programs) != 1:
            raise MissingRightBrace(f'Missing right brace for left brace(s): {instructions}')
        return Progn.or_single_program(programs[0])

    @staticmethod
    def from_rbf_str(rbf_str: str) -&gt; 'RBFProgram':
        rbf_str = ''.join(c for c in rbf_str if c in '+-[]1234567890')
        instructions = [(op_code, int(register)) for op_code, register in zip(rbf_str[::2], rbf_str[1::2])]
        return RBFProgram.from_instructions(instructions)

...

class Loop(RBFProgram):
    ...

    def run(self, memory: list[int]) -&gt; None:
        fast_memory = memory
        slow_memory = list(memory)  # Copy the memory

        while fast_memory[self.register]:
            self.inner_code.run(fast_memory)
            if fast_memory == slow_memory:
                raise InfiniteLoop()

            if not fast_memory[self.register]:
                break

            self.inner_code.run(fast_memory)
            # Note: Since fast_memory[self.register] has always been non-zero,
            #        then slow_memory[self.register] has always been non-zero.
            self.inner_code.run(slow_memory)
            if fast_memory == slow_memory:
                raise InfiniteLoop()

...

# For now, we're trying to write a program that can find something &quot;as complex&quot; as multiplication, so we just check
# that the program can multiply 2 cells.
def program_works(program: RBFProgram) -&gt; bool:
    for a, b in itertools.product(range(NUM_CELL_VALUES), repeat=NUM_INPUT_REGISTERS):
        memory = [a, b, 0, 0]
        try:
            program.run(memory)
        except InfiniteLoop:
            return False
        if memory != [(a * b) % NUM_CELL_VALUES, 0, 0, 0]:
            return False
    return True


def main():
    instructions_that_do_nothing = []
    q = collections.deque([instructions_that_do_nothing])
    num_infinite_programs = 0
    num_malformed_programs = 0
    for i in itertools.count(1):
        instructions = q.popleft()
        if i &amp; (i - 1) == 0:  # if i is a power of 2.
            print(f'Iteration/Number of programs processed: {i}')
            print(f'Length of q (programs waiting to be processed): {len(q)}')
            print(f'Number of instructions in current/longest program: {len(instructions)}')
            print(f'Percent of programs that infinite loop: {100 * num_infinite_programs / (i + len(q)):.2f}%')
            print(f'Percent of programs missing left brace: {100 * num_malformed_programs / (i + len(q)):.2f}%')
            print()

        try:
            program = simplified_program(RBFProgram.from_instructions(instructions))
        except MissingRightBrace:
            pass  # We will eventually output programs with the matching right-brace
        else:
            if program_works(program):
                print('Program found!: ')
                print(program.as_bf_str())
                print(repr(program))
                return

        for op_code in '-+[]':
            for register in range(NUM_REGISTERS):
                next_instructions = copy.copy(instructions)
                next_instructions.append((op_code, register))

                # Don't use space in the q if the program cannot ever work
                try:
                    simplified_program(RBFProgram.from_instructions(next_instructions))
                except InfiniteLoop:
                    num_infinite_programs += 1
                    continue
                except MissingLeftBrace:
                    num_malformed_programs += 1
                    continue
                except MissingRightBrace:
                    pass

                q.append(next_instructions)

</code></pre>
<p>On my (old) laptop, this code used about 7.4GiB in 7 minutes and got about this far:</p>
<pre><code>...

Iteration/Number of programs processed: 2097152
Length of q (programs waiting to be processed): 13364941
Number of instructions in current/longest program: 8
Percent of programs that infinite loop: 5.36%
Percent of programs missing left brace: 3.15%

Iteration/Number of programs processed: 4194304
Length of q (programs waiting to be processed): 26948531
Number of instructions in current/longest program: 8
Percent of programs that infinite loop: 5.04%
Percent of programs missing left brace: 2.70%
</code></pre>
<p>For my setup, memory is more constrained than compute time but before optimizing the memory usage directly, let's try to avoid processing duplicate programs. We know from earlier that lots of programs will modify <code>memory</code> in exactly the same way like <code>[[-]]+</code>, <code>[--+]+</code>, and <code>[+]++-</code>.</p>
<p>One other thing... At this point, we have successfully written code that can find RBF/BF code that performs some operation. See what happens when we change <code>program_works</code> to go from looking for multiplication to looking for addition (by changing <code>*</code> to <code>+</code> in <code>if memory != [(a * b) % NUM_CELL_VALUES, 0, 0, 0]:</code>).</p>
<pre><code>...

Iteration/Number of programs processed: 1024
Length of q (programs waiting to be processed): 5883
Number of instructions in current/longest program: 4
Percent of programs that infinite loop: 8.74%
Percent of programs missing left brace: 9.76%

Program found!:
&gt;[-&lt;+&gt;]
DestructiveAdd(1, [(0, 1)])
</code></pre>
<h3>Detecting duplicates</h3>
<p>Unfortunately, there's no great way to detect all duplicates just by analyzing the RBF code directly but we can eliminate <em>some</em> duplicates by using <code>simplified_program</code> to canonical our programs and check for duplicates.</p>
<pre><code class="language-python">def main():
    instructions_that_do_nothing = []
    seen_programs = set()
    q = collections.deque([instructions_that_do_nothing])
    num_infinite_programs = 0
    num_malformed_programs = 0
    num_duplicate_programs = 0
    for i in itertools.count(1):
        instructions = q.popleft()
        if i &amp; (i - 1) == 0:  # if i is a power of 2.
            print(f'Iteration/Number of programs processed: {i}')
            print(f'Length of q (programs waiting to be processed): {len(q)}')
            print(f'Number of instructions in current/longest program: {len(instructions)}')
            print(f'Percent of programs that infinite loop: {100 * num_infinite_programs / (i + len(q)):.2f}%')
            print(f'Percent of programs missing left brace: {100 * num_malformed_programs / (i + len(q)):.2f}%')
            print(f'Percent of programs that are duplicate: {100 * num_duplicate_programs / (i + len(q)):.2f}%')
            print()

        try:
            program = simplified_program(RBFProgram.from_instructions(instructions))
        except MissingRightBrace:
            pass  # We will eventually output programs with the matching right-brace
        else:
            # Since program is already a simplified_program, certain &quot;duplicate&quot; patterns will already be removed.
            # For example, &quot;--+&quot; and &quot;-&quot; will both result in the same instructions.
            program_key = tuple(program.instructions())
            if program_key in seen_programs:
                num_duplicate_programs += 1
                continue
            seen_programs.add(program_key)

            if program_works(program):
                print('Program found!: ')
                print(program.as_bf_str())
                print(repr(program))
                return

        for op_code in '-+[]':
            for register in range(NUM_REGISTERS):
                next_instructions = copy.copy(instructions)
                next_instructions.append((op_code, register))

                # Don't use space in the q if the program cannot ever work
                try:
                    simplified_program(RBFProgram.from_instructions(next_instructions))
                except InfiniteLoop:
                    num_infinite_programs += 1
                    continue
                except MissingLeftBrace:
                    num_malformed_programs += 1
                    continue
                except MissingRightBrace:
                    pass

                q.append(next_instructions)
</code></pre>
<p>Six minutes and 8.7GiB of memory later, we see similar progress but at higher memory usage!</p>
<pre><code>...

Iteration/Number of programs processed: 2097152
Length of q (programs waiting to be processed): 13170653
Number of instructions in current/longest program: 8
Percent of programs that infinite loop: 5.09%
Percent of programs missing left brace: 1.43%
Percent of programs that are duplicate: 0.42%

Iteration/Number of programs processed: 4194304
Length of q (programs waiting to be processed): 26685683
Number of instructions in current/longest program: 8
Percent of programs that infinite loop: 4.67%
Percent of programs missing left brace: 1.01%
Percent of programs that are duplicate: 0.37%
</code></pre>
<p>Perhaps the way that we are detecting duplicates is not thorough enough. Let's compare them directly!</p>
<h4>Brute-force comparisons</h4>
<pre><code class="language-python">class RBFProgram:
    ...

    def __hash__(self) -&gt; int:
        some_results = []
        # Note: We use % NUM_CELL_VALUES in case NUM_CELL_VALUES is very small
        some_cell_values = [x % NUM_CELL_VALUES for x in range(-2, 3)]
        for memory in itertools.product(some_cell_values, repeat=NUM_REGISTERS):
            memory = list(memory)
            try:
                self.run(memory)
            except InfiniteLoop:
                memory = (None,)
            some_results.append(tuple(memory))
        return hash(tuple(some_results))

    def __eq__(self, other: 'RBFProgram') -&gt; bool:
        for memory in itertools.product(range(NUM_CELL_VALUES), repeat=NUM_REGISTERS):
            memory = list(memory)
            other_memory = list(memory)
            try:
                self.run(memory)
            except InfiniteLoop:
                memory = None
            try:
                other.run(other_memory)
            except InfiniteLoop:
                other_memory = None
            if memory != other_memory:
                return False
        return True

...

def main():
    ...
    for i in itertools.count(1):
      ...
        try:
            program = simplified_program(RBFProgram.from_instructions(instructions))
        except MissingRightBrace:
            pass  # We will eventually output programs with the matching right-brace
        else:
            # Since program is already a simplified_program, certain &quot;duplicate&quot; patterns will already be removed.
            # For example, &quot;--+&quot; and &quot;-&quot; will both result in the same instructions.
            if program in seen_programs:
                num_duplicate_programs += 1
                continue
            seen_programs.add(program)

            if program_works(program):
                print('Program found!: ')
                print(program.as_bf_str())
                print(repr(program))
                return
    ...
</code></pre>
<p>After 6.5 minutes, it detected more duplicates and only used 1.8GiB of memory... because it was so incredibly slow that it didn't have the chance to do much useful work:</p>
<pre><code>...
Iteration/Number of programs processed: 2048
Length of q (programs waiting to be processed): 11666
Number of instructions in current/longest program: 5
Percent of programs that infinite loop: 7.07%
Percent of programs missing left brace: 1.09%
Percent of programs that are duplicate: 1.41%

Iteration/Number of programs processed: 4096
Length of q (programs waiting to be processed): 23836
Number of instructions in current/longest program: 5
Percent of programs that infinite loop: 6.63%
Percent of programs missing left brace: 0.72%
Percent of programs that are duplicate: 1.24%
</code></pre>
<p>What if we set <code>NUM_CELL_VALUES = 5</code>? After 5 minutes and 7.7GiB:</p>
<pre><code>...

Iteration/Number of programs processed: 2097152
Length of q (programs waiting to be processed): 13456769
Number of instructions in current/longest program: 8
Percent of programs that infinite loop: 4.28%
Percent of programs missing left brace: 0.01%
Percent of programs that are duplicate: 0.45%

Iteration/Number of programs processed: 4194304
Length of q (programs waiting to be processed): 27088903
Number of instructions in current/longest program: 9
Percent of programs that infinite loop: 4.11%
Percent of programs missing left brace: 0.01%
Percent of programs that are duplicate: 0.39%
</code></pre>
<p>That's progress, although it's not enough progress. Something fundamentally has to change.</p>
<h2>The Final Solution</h2>
<p>Even though, we greatly limited ourselves to just 2 registers and only 5 possible cell values, the amount of memory it takes to get up to RBF programs with <em>just</em> 9 instructions is... too much. We need to get to 19!</p>
<p>Writing this post has taken more of my time than I'd like so I'm going to stop building up to the end goal and just JUMP to there!</p>
<p>To really make this work, I tried everything above but ultimately needed to make these changes (in no particular order):</p>
<ul>
<li>Use a faster lower-memory language (C++)</li>
<li>Change how programs are constructed from 1-instruction at a time to loops and concatenation</li>
<li>The program we're searching for (e.g. multiplication) is a concatenation of 2 smaller programs</li>
<li>Filter out only "start" programs that lead to distinct memory states for input memory states that should have different outputs</li>
<li>Filter out only "end" programs that have the necessary output memory states</li>
<li>Keep NUM_CELL_VALUES low</li>
<li>Change how programs are represented to be lookup tables from starting memory state to ending state</li>
<li>Each possible memory state is converted to an integer type (and infinite loops are represented as the number 0)</li>
<li>"Rewrite" programs that always had a register ending at 0 as a way to allow some programs to use more registers than were being emulated</li>
<li>Filter out programs that infinite loop under <strong>any</strong> memory input</li>
</ul>
<p>All of these changes together look like this:</p>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;cmath&gt;
#include &lt;cstdint&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

using namespace std;

constexpr int powi(int b, int p) {
  int result = 1;
  for (int i = 0; i &lt; p; ++i) {
    result *= b;
  }
  return result;
}

// Note: Removing programs that infinite loop (under at least 1 input), usually make the search faster *but*
// it can make it take longer and/or not find the *shortest* RBF program that works.
constexpr bool REMOVE_PROGRAMS_THAT_EVER_INFINITE_LOOP = true;
constexpr bool IGNORE_IRRELEVANT_START_PROGRAM_STATES = true;
constexpr bool IGNORE_IRRELEVANT_END_PROGRAM_STATES = true;


constexpr int NUM_CELL_VALUES = 5;
constexpr int NUM_REGISTERS = 3;  // Does not include register rewrites :)
constexpr int NUM_TOTAL_STATES = powi(NUM_CELL_VALUES, NUM_REGISTERS) + 1;
constexpr int NUM_INPUT_REGISTERS = 2;
constexpr int NUM_OUTPUT_REGISTERS = 1;


typedef uint8_t state_t;  // Big enough to hold 0 to NUM_TOTAL_STATES (inclusive)
typedef uint8_t output_state_id_t;  // big enough to hold 0 to the number of unique output states (exclusive)
typedef uint8_t cell_t;  // Big enough to hold 0 to NUM_CELL_VALUES (inclusive)


int memory_to_state(const cell_t* memory) {
  state_t state = 0;
  for (int i = 0; i &lt; NUM_REGISTERS; ++i) {
    state *= NUM_CELL_VALUES;
    state += memory[i];
  }
  return state + 1;
}


inline bool state_is_infinite_loop(const state_t state) {
  return !state;
}


// Fill in memory and return true iff state is valid/not an infinite loop state.
bool state_to_memory(state_t state, cell_t* memory) {
  if (state_is_infinite_loop(state)) {
    return false;
  }
  --state;
  for (int i = NUM_REGISTERS - 1; i &gt;= 0; --i) {
    memory[i] = state % NUM_CELL_VALUES;
    state /= NUM_CELL_VALUES;
  }
  return true;
}

struct StateToMemory {
  cell_t memories[NUM_REGISTERS * NUM_TOTAL_STATES];

  StateToMemory() {
    for (state_t state = 0; state &lt; NUM_TOTAL_STATES; ++state) {
      state_to_memory(state, &amp;memories[state * NUM_REGISTERS]);
    }
  }
  cell_t const* get(state_t state) {
    return &amp;memories[state * NUM_REGISTERS];
  }
  cell_t get(state_t state, int index) {
    return memories[state * NUM_REGISTERS + index];
  }
} state_to_memory_cache;


struct StateToDesiredOutputs {
  cell_t desired_outputs[NUM_OUTPUT_REGISTERS * NUM_TOTAL_STATES];
  output_state_id_t output_state_ids[NUM_TOTAL_STATES];
  int num_unique_outputs;

  StateToDesiredOutputs() {
    for (state_t state = 1; state &lt; NUM_TOTAL_STATES; ++state) {
      const auto x = state_to_memory_cache.get(state, 0);
      const auto y = state_to_memory_cache.get(state, 1);
      // const auto z = state_to_memory_cache.get(state, 2);

      // Below are examples.
      // DON'T FORGET TO UPDATE NUM_INPUT_REGISTERS and NUM_OUTPUT_REGISTERS!
      desired_outputs[state * NUM_OUTPUT_REGISTERS] = (x * y) % NUM_CELL_VALUES;

      // desired_outputs[state * NUM_OUTPUT_REGISTERS] = (x * y) / NUM_CELL_VALUES % NUM_CELL_VALUES;

      // desired_outputs[state * NUM_OUTPUT_REGISTERS] = (x + y) / NUM_CELL_VALUES % NUM_CELL_VALUES;

      // '&lt;[-&lt;-&gt;&gt;+&lt;]&gt;[-&lt;-&gt;]&lt;&lt;&lt;[&gt;[-&gt;-&lt;]&lt;[-]]&gt;&gt;[-&lt;&lt;-&gt;&gt;]&lt;[-]'
      // desired_outputs[state * NUM_OUTPUT_REGISTERS] = x ? y : z;

      // '&lt;[-&lt;[&gt;&gt;+&lt;&lt;[-&gt;&gt;-&lt;&lt;]]&gt;&gt;[-&lt;&lt;-&gt;&gt;]&lt;]&gt;+&lt;+&gt;[-&lt;&lt;[-&gt;&gt;-&lt;&lt;]&gt;[-&lt;+&gt;]&gt;]&lt;'
      // desired_outputs[state * NUM_OUTPUT_REGISTERS] = (x &lt;= y) % NUM_CELL_VALUES;

      // So far, have not found this one!
      // desired_outputs[state * NUM_OUTPUT_REGISTERS] = (cell_t)sqrtl(x) % NUM_CELL_VALUES;

      // '&lt;[-&gt;+&lt;]-&gt;[[&gt;-&lt;---[&gt;-&lt;[-&gt;-&lt;]]]&gt;[+&lt;+&gt;[+[-&gt;-&lt;]]&gt;[-&lt;-&gt;]&lt;]&lt;&lt;+&gt;]'
      // desired_outputs[state * NUM_OUTPUT_REGISTERS] = (cell_t)log2l(x) % NUM_CELL_VALUES;

      // '&lt;[&gt;-&lt;---[&gt;-&lt;[-&gt;-&lt;]]]&gt;[+&lt;+&gt;[+[-&gt;-&lt;]]&gt;[-&lt;-&gt;]&lt;]'
      // desired_outputs[state * NUM_OUTPUT_REGISTERS] = x / 2 % NUM_CELL_VALUES;

      // desired_outputs[state * NUM_OUTPUT_REGISTERS] = x / 3 % NUM_CELL_VALUES;

      // int result = x * NUM_CELL_VALUES + y + NUM_CELL_VALUES*NUM_CELL_VALUES - 1;
      // desired_outputs[state * NUM_OUTPUT_REGISTERS] = result / NUM_CELL_VALUES % NUM_CELL_VALUES;
      // desired_outputs[state * NUM_OUTPUT_REGISTERS + 1] = result % NUM_CELL_VALUES;

      // desired_outputs[state * NUM_OUTPUT_REGISTERS] = x;
      // desired_outputs[state * NUM_OUTPUT_REGISTERS + 1] = y;
      // desired_outputs[state * NUM_OUTPUT_REGISTERS + 2] = (x || y) ? 1 : 0;
    }

    output_state_id_t canonical_output_state_ids[NUM_TOTAL_STATES];
    num_unique_outputs = 0;
    for (state_t state = 1; state &lt; NUM_TOTAL_STATES; ++state) {
      canonical_output_state_ids[state] = -1;
    }
    for (state_t state = 1; state &lt; NUM_TOTAL_STATES; ++state) {
      cell_t memory[NUM_REGISTERS];
      set_memory(state, memory);
      state_t canonical_state = memory_to_state(memory);
      if (canonical_output_state_ids[canonical_state] == (output_state_id_t)-1) {
        canonical_output_state_ids[canonical_state] = num_unique_outputs;
        ++num_unique_outputs;
      }
      output_state_ids[state] = canonical_output_state_ids[canonical_state];
    }
  }

  output_state_id_t get_id(state_t state) const {
    return output_state_ids[state];
  }

  cell_t get(state_t state, int index) const {
    return desired_outputs[state * NUM_OUTPUT_REGISTERS + index];
  }

  void set_memory(state_t state, cell_t* memory) const {
    for (int i = 0; i &lt; NUM_OUTPUT_REGISTERS; ++i) {
      memory[i] = get(state, i);
    }
    for (int i = NUM_OUTPUT_REGISTERS; i &lt; NUM_REGISTERS; ++i) {
      memory[i] = 0;
    }
  }

  bool matches(state_t state, const cell_t* memory) const {
    for (int i = 0; i &lt; NUM_OUTPUT_REGISTERS; ++i) {
      if (memory[i] != get(state, i)) {
        return false;
      }
    }
    return true;
  }
} state_to_desired_output_cache;


struct Program {
  string rbf;
  state_t states[NUM_TOTAL_STATES];  // 0 means infinite loop

  Program(const string rbf) : rbf(rbf) {
    memset(states, 0, sizeof(states));
  }
  Program() {
    memset(states, 0, sizeof(states));
  }

  Program(const Program&amp; other) = default;
  Program(Program&amp;&amp; other) = default;

  string as_bf_str(int starting_register=0) const {
    string bf;
    int cur_register = starting_register;
    for (int i = 0; i &lt; rbf.size() - 1; i += 2) {
      int next_register = rbf[i + 1] - '0';
      if (next_register &gt; cur_register) {
        bf.resize(bf.size() + next_register - cur_register, '&gt;');
      } else {
        bf.resize(bf.size() + cur_register - next_register, '&lt;');
      }
      bf.push_back(rbf[i]);
      cur_register = next_register;
    }
    return bf;
  }

  // Return true if there's at least 1 input which does not infinite loop *AND* updates the state
  bool is_nontrivial_program() const {
    if (REMOVE_PROGRAMS_THAT_EVER_INFINITE_LOOP) {
      // Note: The loop below filter programs that infinite loop on any input (not just all inputs).
      // This filtering may be too aggressive
      for (state_t state = 1; state &lt; NUM_TOTAL_STATES; ++state) {
        if (states[state] == 0) {
          return false;
        }
      }
    }
    for (state_t state = 1; state &lt; NUM_TOTAL_STATES; ++state) {
      if (states[state] &amp;&amp; states[state] != state) {
        return true;
      }
    }
    return false;
  }

  int next_register_available_ge(int minimum_register) const {
    set&lt;int&gt; registers_used;
    for (int i = 1; i &lt; rbf.size(); i += 2) {
      int r = rbf[i] - '0';
      registers_used.insert(r);
    }
    for (int r = minimum_register; ; ++r) {
      if (registers_used.find(r) == registers_used.end()) {
        return r;
      }
    }
  }

  int next_out_of_bounds_register_available() const {
    return next_register_available_ge(NUM_REGISTERS);
  }

  static Program noop() {
    Program result;
    for (state_t state = 1; state &lt; NUM_TOTAL_STATES; ++state) {
      result.states[state] = state;
    }
    return result;
  }

  static Program increment(int index) {
    string rbf = &quot;+0&quot;;
    rbf[1] += index;
    Program result(rbf);
    // Programs result;

    cell_t memory[NUM_REGISTERS];
    for (state_t state = 1; state &lt; NUM_TOTAL_STATES; ++state) {
      state_to_memory(state, memory);
      ++memory[index];
      memory[index] %= NUM_CELL_VALUES;
      result.states[state] = memory_to_state(memory);
    }

    return result;
  }

  static Program decrement(int index) {
    string rbf = &quot;-0&quot;;
    rbf[1] += index;
    Program result(rbf);
    cell_t memory[NUM_REGISTERS];
    for (state_t state = 1; state &lt; NUM_TOTAL_STATES; ++state) {
      state_to_memory(state, memory);
      memory[index] += NUM_CELL_VALUES - 1;  // Try to avoid negative modulo below. Oh Python, how I miss you.
      memory[index] %= NUM_CELL_VALUES;
      result.states[state] = memory_to_state(memory);
    }

    return result;
  }

  static Program loop(int index, const Program&amp; inner_code) {
    string rbf;
    rbf.reserve(inner_code.rbf.size() + 4);
    rbf.append(&quot;[0&quot;);
    rbf[1] += index;
    rbf.append(inner_code.rbf);
    rbf.append(&quot;]0&quot;);
    rbf[rbf.size() - 1] += index;
    Program result(rbf);
    bitset&lt;NUM_TOTAL_STATES&gt; seen_states;

    // Phase 1: Set result.states to be 1 iteration of the loop (or 0 if the loop does not run)
    for (state_t start_state = 1; start_state &lt; NUM_TOTAL_STATES; ++start_state) {
      result.states[start_state] = state_to_memory_cache.get(start_state, index) == 0
          ? start_state
          : inner_code.states[start_state];
    }

    for (state_t start_state = 1; start_state &lt; NUM_TOTAL_STATES; ++start_state) {
      state_t seen_array[NUM_TOTAL_STATES];
      int num_seen = 0;
      seen_states.reset();
      state_t state = result.states[start_state];
      while(state) {
        if (seen_states[state]) {
          state = 0;  // infinite loop detected
          break;
        }

        if (state_to_memory_cache.get(state, index) == 0) {
          break;  // We finished the loop!
        }

        seen_states[state] = true;
        seen_array[num_seen] = state;
        ++num_seen;
        state = result.states[state];
      }
      result.states[start_state] = state;
      for (int i = 0; i &lt; num_seen; ++i) {
        result.states[seen_array[i]] = state;
      }
    }

    return result;
  }

  static Program concat(const Program&amp; a, const Program&amp; b) {
    Program result;
    result.rbf.reserve(a.rbf.size() + b.rbf.size());
    result.rbf.append(a.rbf);
    result.rbf.append(b.rbf);

    for (state_t state = 1; state &lt; NUM_TOTAL_STATES; ++state) {
      result.states[state] = b.states[a.states[state]];
    }
    return result;
  }

  // Return true iff every state where memory[index] == 0 ends with memory[index] == 0.
  // This is useful because it means this program can take advantage of a known zeroed out cell and leave that cell
  // in the same state.
  bool cell_ends_at_0_when_starting_at_0(int index) const {
    for (state_t state = 1; state &lt; NUM_TOTAL_STATES; ++state) {
      if (state_to_memory_cache.get(state, index) == 0) {  // TODO: Precompute which states start with memory[index] == 0
        state_t end_state = states[state];
        if (end_state == 0 || state_to_memory_cache.get(end_state, index) != 0) {
          return false;
        }
      }
    }
    return true;
  }

  // Assuming p.cell_starts_and_ends_at_0(old_index), rewrite p so that old_index is now an out-of-bounds new_index, allowing
  // old_index to be used for other computations
  static Program with_0_register_rewritten(const Program&amp; p, int old_index, int new_index) {
    assert(p.cell_ends_at_0_when_starting_at_0(old_index));
    assert(new_index &gt;= NUM_REGISTERS);
    string rbf(p.rbf);
    for (int i = 1; i &lt; rbf.length(); i += 2) {
      if (rbf[i] - '0' == old_index) {
        rbf[i] = '0' + new_index;
      }
    }
    Program result(rbf);
    cell_t memory[NUM_REGISTERS];
    for (state_t state = 1; state &lt; NUM_TOTAL_STATES; ++state) {
      state_to_memory(state, memory);
      memory[old_index] = 0;
      state_t effective_state = memory_to_state(memory);
      state_t end_state = p.states[effective_state];
      state_to_memory(end_state, memory);
      memory[old_index] = state_to_memory_cache.get(state, old_index);
      result.states[state] = memory_to_state(memory);
    }
    return result;
  }

  bool operator!=(const Program&amp; other) const {
    return memcmp(states, other.states, sizeof(states));
  }

  bool operator==(const Program&amp; other) const {
    return memcmp(states, other.states, sizeof(states)) == 0;
  }

  bool operator&lt;(const Program&amp; other) const {
    return memcmp(states, other.states, sizeof(states)) &lt; 0;
  }
};

template&lt;&gt;
struct std::hash&lt;Program&gt;
{
  std::size_t operator()(const Program&amp; s) const noexcept
  {
      return std::hash&lt;string_view&gt;{}(
        string_view((char*)&amp;s.states, sizeof(s.states)));
  }
};


typedef unordered_set&lt;Program&gt; SetOfPrograms;


vector&lt;SetOfPrograms&gt; UNIQ_PROGRAM_CACHE;


bool program_in_unique_program_cache(const Program&amp; p) {
  for (const SetOfPrograms&amp; programs : UNIQ_PROGRAM_CACHE) {
    if (programs.find(p) != programs.end()) {
      return true;
    }
  }
  return false;
}


const SetOfPrograms&amp; unique_programs_of_length(int n) {
  if (UNIQ_PROGRAM_CACHE.size() &gt; n) {
    return UNIQ_PROGRAM_CACHE[n];
  }
  unique_programs_of_length(n - 1); // prefill cache of smaller programs
  UNIQ_PROGRAM_CACHE.resize(n + 1);
  SetOfPrograms&amp; result = UNIQ_PROGRAM_CACHE[n];
  // Try all combinations of smaller programs
  for (int a_size = 1; a_size &lt; n; ++a_size) {
    int b_size = n - a_size;
    for (const Program&amp; a : UNIQ_PROGRAM_CACHE[a_size]) {
      for (const Program&amp; b : UNIQ_PROGRAM_CACHE[b_size]) {
        const Program new_program = Program::concat(a, b);
        if (new_program.is_nontrivial_program() &amp;&amp; !program_in_unique_program_cache(new_program)) {
          result.insert(move(new_program));
        }
      }
    }
  }
  // Try all loops of size n-1 programs
  for (const Program&amp; inner_code : UNIQ_PROGRAM_CACHE[n - 1]) {
    for (int r = 0; r &lt; NUM_REGISTERS; ++r) {
      Program new_program = Program::loop(r, inner_code);
      if (new_program.is_nontrivial_program() &amp;&amp; !program_in_unique_program_cache(new_program)) {
        result.insert(move(new_program));
      }
    }
  }
  // Try rewrites when possible! BF Programs like [-&gt;+&gt;+&lt;&lt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;] essentially
  // just use register 2 as temporary storage in order to copy register 0 to register 1.
  for (const Program&amp; p : UNIQ_PROGRAM_CACHE[n - 1]) {
    for (int r = 0; r &lt; NUM_REGISTERS; ++r) {
      if (p.cell_ends_at_0_when_starting_at_0(r)) {
        int new_register = p.next_out_of_bounds_register_available();
        Program new_program = Program::with_0_register_rewritten(p, r, new_register);
        if (new_program.is_nontrivial_program() &amp;&amp; !program_in_unique_program_cache(new_program)) {
          result.insert(move(new_program));
        }
      }
    }
  }
  return result;
}


vector&lt;state_t&gt; get_valid_start_states() {
  vector&lt;state_t&gt; valid_start_states;
  for (state_t state = 1; state &lt; NUM_TOTAL_STATES; ++state) {
    const cell_t* memory = state_to_memory_cache.get(state);
    bool valid_state = true;
    for (int i = NUM_INPUT_REGISTERS; i &lt; NUM_REGISTERS; ++i) {
      if (memory[i] != 0) {
        valid_state = false;
        break;
      }
    }
    if (valid_state) {
      valid_start_states.push_back(state);
    }
  }
  return valid_start_states;
}


map&lt;output_state_id_t, vector&lt;state_t&gt;&gt; get_output_state_ids(const vector&lt;state_t&gt;&amp; valid_start_states) {
  map&lt;output_state_id_t, vector&lt;state_t&gt;&gt; output_state_ids;
  for (state_t state : valid_start_states) {
    output_state_ids[state_to_desired_output_cache.get_id(state)].push_back(state);
  }
  return output_state_ids;
}


SetOfPrograms get_start_program_candidates(
    const vector&lt;state_t&gt;&amp; valid_start_states,
    const map&lt;output_state_id_t, vector&lt;state_t&gt;&gt;&amp; output_state_ids) {
  SetOfPrograms start_programs;
  for (const SetOfPrograms&amp; some_programs : UNIQ_PROGRAM_CACHE) {
    for (const Program&amp; a : some_programs) {
      // Skip processing &quot;a&quot; programs that cannot possibly give the right answer
      bool a_is_valid = true;
      bitset&lt;NUM_TOTAL_STATES&gt; all_intermediate_states;
      for (const auto&amp; output_group : output_state_ids) {
        bitset&lt;NUM_TOTAL_STATES&gt; group_intermidiate_states;
        for (const state_t start_state : output_group.second) {
          state_t state = a.states[start_state];
          if (all_intermediate_states[state] || state == 0) {
            // We've detected that 2 different starting states that should have different outputs,
            // have the same intermediate state (so it is not possible for them to have different outputs)
            a_is_valid = false;
            break;
          }
          group_intermidiate_states[state] = 1;
        }
        if (!a_is_valid) {
          break;
        }
        all_intermediate_states |= group_intermidiate_states;
      }
      if (a_is_valid) {
        assert(all_intermediate_states.count() &gt;= output_state_ids.size());
        if (IGNORE_IRRELEVANT_START_PROGRAM_STATES) {
          Program rewritten_a(a);
          for (state_t s = 1; s &lt; NUM_TOTAL_STATES; ++s) {
            if (find(valid_start_states.begin(), valid_start_states.end(), s) == valid_start_states.end()) {
              rewritten_a.states[s] = 0;
            }
          }
          start_programs.insert(rewritten_a);
        } else {
          start_programs.insert(a);
        }
      }
    }
  }
  return start_programs;
}


SetOfPrograms get_end_program_candidates(
    const vector&lt;state_t&gt;&amp; valid_start_states,
    const map&lt;output_state_id_t, vector&lt;state_t&gt;&gt;&amp; output_state_ids) {
  SetOfPrograms end_program_candidates;
  bitset&lt;NUM_CELL_VALUES * NUM_OUTPUT_REGISTERS&gt; necessary_values;
  for (const auto&amp; kv : output_state_ids) {
    necessary_values[kv.first] = 1;
  }
  for (const SetOfPrograms&amp; some_programs : UNIQ_PROGRAM_CACHE) {
    for (const Program&amp; b : some_programs) {
      bitset&lt;NUM_CELL_VALUES * NUM_OUTPUT_REGISTERS&gt; missing_values(necessary_values);
      // Check if b is a (non strict) superset of end states needed
      for (state_t start_state = 1; start_state &lt; NUM_TOTAL_STATES; ++start_state) {
        missing_values[state_to_desired_output_cache.get_id(b.states[start_state])] = 0;
      }
      if (missing_values.none()) {
        if (IGNORE_IRRELEVANT_END_PROGRAM_STATES) {
          Program rewritten_b(b);
          for (state_t s = 1; s &lt; NUM_TOTAL_STATES; ++s) {
            state_t es = rewritten_b.states[s];
            cell_t memory[NUM_REGISTERS];
            state_to_memory(es, memory);
            for (int i = NUM_OUTPUT_REGISTERS; i &lt; NUM_REGISTERS; ++i) {
              memory[i] = 0;
            }
            rewritten_b.states[s] = memory_to_state(memory);
          }
          end_program_candidates.insert(rewritten_b);
        } else {
          end_program_candidates.insert(b);
        }
      }
    }
  }
  return end_program_candidates;
}

size_t uniq_program_cache_size() {
  size_t result = 0;
  for (SetOfPrograms ps : UNIQ_PROGRAM_CACHE) {
    result += ps.size();
  }
  return result;
}


// Checks all 2-grams of programs in UNIQ_PROGRAM_CACHE to see if any of them are equivalent to doing a multiplication!
void check_programs() {
  vector&lt;state_t&gt; valid_start_states = get_valid_start_states();
  map&lt;output_state_id_t, vector&lt;state_t&gt;&gt; output_state_ids = get_output_state_ids(valid_start_states);
  SetOfPrograms start_programs = get_start_program_candidates(valid_start_states, output_state_ids);
  SetOfPrograms end_programs = get_end_program_candidates(valid_start_states, output_state_ids);

  cout &lt;&lt; start_programs.size() &lt;&lt; &quot; Programs are valid start Programs.\n&quot;;
  cout &lt;&lt; end_programs.size() &lt;&lt; &quot; Programs are valid end Programs.\n&quot;;
  size_t checking_combos = start_programs.size() * end_programs.size();
  double total_combos = (double)uniq_program_cache_size() * uniq_program_cache_size();
  cout &lt;&lt; &quot;Checking &quot; &lt;&lt; checking_combos &lt;&lt; &quot; combinations (&quot;
    &lt;&lt; 100.0 * checking_combos / total_combos &lt;&lt; &quot;% of &quot; &lt;&lt; total_combos &lt;&lt; &quot; possible combinations).\n&quot;;

  // Checks every concatenation of a start_program_candidate with a end_program_candidate
  for (const Program&amp; a : start_programs) {
    for (const Program&amp; b : end_programs) {
      const Program p = Program::concat(a, b);
      bool program_works = true;
      for (state_t start_state : valid_start_states) {
        state_t state = p.states[start_state];
        const cell_t* memory = state_to_memory_cache.get(state);
        if (state == 0 || !state_to_desired_output_cache.matches(start_state, memory)) {
          program_works = false;
          break;
        }
      }
      if (program_works) {
        for (state_t start_state : valid_start_states) {
          const cell_t* start_memory = state_to_memory_cache.get(start_state);
          state_t state = p.states[start_state];
          const cell_t* memory = state_to_memory_cache.get(state);
          for (int i = 0; i &lt; NUM_REGISTERS; ++i) {
            cout &lt;&lt; (int)start_memory[i] &lt;&lt; ' ';
          }
          cout &lt;&lt; &quot; --&gt;  &quot;;
          if (IGNORE_IRRELEVANT_END_PROGRAM_STATES) {
            for (int i = 0; i &lt; NUM_OUTPUT_REGISTERS; ++i) {
              cout &lt;&lt; (int)memory[i] &lt;&lt; ' ';
            }
            for (int i = NUM_OUTPUT_REGISTERS; i &lt; NUM_REGISTERS; ++i) {
              cout &lt;&lt; &quot;? &quot;;
            }
          } else {
            for (int i = 0; i &lt; NUM_REGISTERS; ++i) {
              cout &lt;&lt; (int)memory[i] &lt;&lt; ' ';
            }
          }
          cout &lt;&lt; endl;
        }
        cout
            &lt;&lt; &quot;RBF: &quot; &lt;&lt; p.rbf &lt;&lt; endl
            &lt;&lt; &quot;BF: &quot; &lt;&lt; p.as_bf_str() &lt;&lt; endl
            &lt;&lt; &quot;BF (starting at register &quot; &lt;&lt; NUM_INPUT_REGISTERS &lt;&lt; &quot;): &quot;  &lt;&lt; p.as_bf_str(NUM_INPUT_REGISTERS) &lt;&lt; endl;
        exit(0);
      }
    }
  }
  cout &lt;&lt; &quot;Could not find desired program... (yet).\n&quot;;
}


int main(int argc, const char* argv[]) {
  assert(1L &lt;&lt; (8 * sizeof(state_t)) &gt;= NUM_TOTAL_STATES);

  // Fill first 2 layers of UNIQ_PROGRAM_CACHE
  assert(UNIQ_PROGRAM_CACHE.empty());
  UNIQ_PROGRAM_CACHE.resize(2);
  UNIQ_PROGRAM_CACHE[0].insert(Program::noop());
  for (int i = 0; i &lt; NUM_REGISTERS; ++i) {
    UNIQ_PROGRAM_CACHE[1].insert(Program::decrement(i));
    UNIQ_PROGRAM_CACHE[1].insert(Program::increment(i));
  }

  for (int i = 0; ; ++i) {
    const auto&amp; programs = unique_programs_of_length(i);
    cout &lt;&lt; &quot;Found &quot; &lt;&lt; programs.size() &lt;&lt; &quot; unique RBF programs with &quot; &lt;&lt; i &lt;&lt; &quot; loops/increments.&quot; &lt;&lt; endl;

    if (i &gt;= 10) {
      check_programs();
    }
  }

  return 0;
}
</code></pre>
<p>After ~31 seconds and &lt;1GiB, outputs:</p>
<pre><code>Found 1 unique RBF programs with 0 loops/increments.
Found 6 unique RBF programs with 1 loops/increments.
Found 21 unique RBF programs with 2 loops/increments.
Found 62 unique RBF programs with 3 loops/increments.
Found 207 unique RBF programs with 4 loops/increments.
Found 870 unique RBF programs with 5 loops/increments.
Found 3774 unique RBF programs with 6 loops/increments.
Found 16431 unique RBF programs with 7 loops/increments.
Found 73824 unique RBF programs with 8 loops/increments.
Found 344618 unique RBF programs with 9 loops/increments.
Found 1641549 unique RBF programs with 10 loops/increments.
55543 Programs are valid start Programs.
76522 Programs are valid end Programs.
Checking 4250261446 combinations (0.0981115% of 4.33207e+12 possible combinations).
0 0 0  --&gt;  0 ? ?
0 1 0  --&gt;  0 ? ?
0 2 0  --&gt;  0 ? ?
0 3 0  --&gt;  0 ? ?
0 4 0  --&gt;  0 ? ?
1 0 0  --&gt;  0 ? ?
1 1 0  --&gt;  1 ? ?
1 2 0  --&gt;  2 ? ?
1 3 0  --&gt;  3 ? ?
1 4 0  --&gt;  4 ? ?
2 0 0  --&gt;  0 ? ?
2 1 0  --&gt;  2 ? ?
2 2 0  --&gt;  4 ? ?
2 3 0  --&gt;  1 ? ?
2 4 0  --&gt;  3 ? ?
3 0 0  --&gt;  0 ? ?
3 1 0  --&gt;  3 ? ?
3 2 0  --&gt;  1 ? ?
3 3 0  --&gt;  4 ? ?
3 4 0  --&gt;  2 ? ?
4 0 0  --&gt;  0 ? ?
4 1 0  --&gt;  4 ? ?
4 2 0  --&gt;  3 ? ?
4 3 0  --&gt;  2 ? ?
4 4 0  --&gt;  1 ? ?
RBF: [0[1-0[1+2+1]1]1[0-1-0]0]0-1[2-2[1-3+1-0]1[3-3+1]3]2
BF: [&gt;[&lt;-&gt;[&gt;+&lt;+]]&lt;[&gt;-&lt;-]]&gt;-&gt;[-&lt;[&gt;&gt;-&lt;&lt;+&lt;-&gt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;]
BF (starting at register 2): &lt;&lt;[&gt;[&lt;-&gt;[&gt;+&lt;+]]&lt;[&gt;-&lt;-]]&gt;-&gt;[-&lt;[&gt;&gt;-&lt;&lt;+&lt;-&gt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;]
</code></pre>
<p>Woohoo! It works. The original goal was to be able to search up through programs that were at least as "complex" as the multiplication BF from the beginning. We determined that's roughly 41 BF instructions, 19 RBF instructions, or 4 loops and 11 increments. On my 16GiB laptop, this program can find all the RBF programs with up to 10 loops/increments and then search through all 2-gram concatenations of those programs within a minute <strong>and</strong> all RBF programs up to 11 loops/increments before it runs out of memory! From unimaginably large numbers of possible BF programs to search through to trillions of RBF programs all the way done to the millions that a single laptop can handle.</p>
<p>If you look at the <code>StateToDesiredOutputs</code> class above, you can see lots of examples of other functions that we can find RBF (and BF) code for as well as some that I couldn't.</p>
<h2>Other Things You May Want to Learn About</h2>
<p>Checkout <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> if you want to learn a little more about what numbers represent what (English) characters or <a href="https://en.wikipedia.org/wiki/UTF-8">Unicode and UTF-8</a> if you want to learn a lot more, including how to output emojis and non-English characters.</p>
<p>You might also enjoy learning about Turing Machines, compilers, or Common LISP.</p>
<h3>Compiling to BF</h3>
<p>While I wouldn't want to write a complicated program in BF, I <em>did/do</em> enjoy <a href="https://github.com/mikelmcdaniel/simple-lisp2bf-v2/tree/master">writing a program (in Python) that takes non-BF code in and outputs BF code</a>.</p>
<p>The following Python-like program can be compiled to BF.</p>
<pre><code class="language-python">def print_number(x):
    if x &gt;= 100:
        print(x / 100 + '0')
    if x &gt;= 10:
        print(x / 10 % 10 + '0')
    print(x % 10 + '0')

def is_digit(c):
    '0' &lt;= c and c &lt;= '9'

def read_num():
    c = read()
    result = 0
    while is_digit(c):
        result = result * 10 + (c - '0')
        c = read()
    result

def start():
    print(&quot;Enter equation to solve (e.g. '123 / 45'): &quot;)
    a = read_num()
    op_code = read()
    read()
    b = read_num()
    print(&quot;\n&quot;)
    if op_code == '+':
        result = a + b
    elif op_code == '-':
        result = a - b
    elif op_code == '*':
        result = a * b
    elif op_code == '/':
        result = a / b
    else:
        print(&quot;Sorry! Only +, -, *, and / are supported operations but we got '&quot;, op_code, &quot;'.\n&quot;)
        exit()
    print_number(a)
    print(&quot; &quot;, op_code, &quot; &quot;)
    print_number(b)
    print(&quot; = &quot;)
    print_number(result)
    print(&quot;\n&quot;)
</code></pre>
<p>If you run that BF program and type in something like "6 * 7", it outputs:</p>
<pre><code>Enter equation to solve (e.g. '123 / 45'): 16 * 7
16 * 7 = 112
</code></pre>
<p>I think it'd take too long to do a proper write up about the compiler and the compiler's code needs to be cleaned up, tested, and documented but it works!</p>

</section>
<!-- Bootstrap core JS-->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
<!-- Core theme JS-->
<script src="https://mikelmcdaniel.github.io/static/js/bootstrap_5.1.3_clean_blog.js"></script>
</body>
</html>