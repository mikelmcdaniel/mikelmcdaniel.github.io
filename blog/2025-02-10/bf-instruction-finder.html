<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Mikel Mcdaniel">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Source Code highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <!-- MathJax -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <!-- Bootstrap core plus theme -->
  <link href="https://mikelmcdaniel.github.io/static/css/bootstrap_5.1.3_cutomized.css" rel="stylesheet" />
  <title>UNFINISHED DRAFT BrainFuck Instruction Finder</title>
  <style>
    @media print {
      .do-not-print {
        display: none;
        position: fixed;
        top: 0;
        visibility: hidden;
      }
    }
  </style>
</head>
<body>
<!-- Navigation-->
<nav class="do-not-print navbar navbar-expand-lg navbar-light" id="mainNav">
  <div class="container px-4 px-lg-5">
    <a class="navbar-brand" href="https://mikelmcdaniel.github.io/">Home</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ms-auto py-4 py-lg-0">
        <li class="nav-item"><a href="https://mikelmcdaniel.github.io/blog" class="nav-link px-lg-3 py-3 py-lg-4">Blog</a></li>
        <li class="nav-item"><a href="https://github.com/mikelmcdaniel" class="nav-link px-lg-3 py-3 py-lg-4">GitHub</a></li>
        <li class="nav-item"><a href="https://www.linkedin.com/in/mikel-mcdaniel-14ba74164/" class="nav-link px-lg-3 py-3 py-lg-4">LinkedIn</a></li>
        <li class="nav-item"><a href="https://mikelmcdaniel.github.io/resume" class="nav-link px-lg-3 py-3 py-lg-4">Résumé</a></li>
      </ul>
    </div>
  </div>
</nav>
<!-- Page Header-->
<header class="do-not-print masthead" style="background-image: url('https://mikelmcdaniel.github.io/static/imgs/code-background.png') ">
  <div class="container position-relative px-4 px-lg-5">
    <div class="row gx-4 gx-lg-5 justify-content-center">
      <div class="col-md-10 col-lg-8 col-xl-7">
        <div class="site-heading">
          <h1>UNFINISHED DRAFT BrainFuck Instruction Finder</h1>
          <span class="subheading">Searching through trillions of code snippets in minutes</span>
        </div>
      </div>
    </div>
  </div>
</header>

<section class="px-3">
  
<h1>THIS IS AN UNFINISHED DRAFT... DO NOT READ IT YET ;)</h1>
<p>This is a post about... writing code to generate BF code that can do any computation... and my goal is to make this post as short and understandable as possible, regardless of your background in math or computers. Some things will be oversimplified for the sake of making it easier to understand.</p>
<p>If you've ever written BF code, then you know its hard to do anything but the most simple tasks with it. Its like having a machine that can assemble atoms together and using it to make an omelet. My idea of a good time.</p>
<h2>What is BF?</h2>
<p>First and foremost, its a way for me to avoid saying BrainFuck because I need you to know that I'm a serious professional and adult who doesn't say F*** too much. I'll refer to it as BF from now on.</p>
<p>If you're already familiar with BF, you can safely skip this section.</p>
<p>Secondly, BF is a very simple programming language that consists of just 8 instructions. The <a href="https://en.wikipedia.org/wiki/Brainfuck">BF Wikipedia article</a>. If you're familiar with Turing machines, BF programs get pretty close and, like a Turing machine, can perform any computation a regular computer can... if you're willing to wait long enough <em>and</em> have enough memory.</p>
<p>BF programs are text-based programs. They can't display pictures and buttons; they can read text you type in (one character at a time) and they can print out text (one character at a time).</p>
<h3>How does BF code work?</h3>
<p>A byte can represent any whole number between 0 and 255. Some numbers are used to represent characters, for example the numbers 48, 65, and 97 represent <code>'0'</code>, <code>'A'</code>, and <code>'a'</code> respectively. As a very nice convenience, the other digits and letters like <code>'1'</code>, <code>'B'</code>, and <code>'c'</code> all have numbers that are just 1, 2, and 3 more than <code>'0'</code>, <code>'A'</code>, and <code>'a'</code>. So... if you wanted to know what number represents <code>'h'</code>, its 97 + 7 = 104.</p>
<h4>Saying "hello" / The first 3 instructions</h4>
<p>When a BF program starts, all bytes it has access to are set to 0 <strong>and</strong> the program starts out only operating on just the 1st byte. Lets say that we wanted to print out "hello". First we have to get our byte from the value 0 to the value 104 so we can print out the "H". We do that with the increment instruction, <code>+</code>, which just adds 1 to our current byte. To get from 0 to 104, we need to repeat <code>+</code> 104 times.</p>
<pre><code>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
</code></pre>
<p>Before the code ran, the bytes in memory looked like [0, 0, 0, ...] but after, they contain [104, 0, 0, ...]</p>
<p>Now we can output our byte using the <code>.</code> instruction.</p>
<pre><code>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.
</code></pre>
<p>Outputs:</p>
<pre><code>h
</code></pre>
<p>Great! Now we just need to output the remaining letters "ello", which are represented with 101, 108, 108, and 111. To go from 104 to 101, we use the decrement instruction, <code>-</code>,  which subtracts 1 from the current byte. Note that the increment and decrement instructions wrap-around, meaning that incrementing a 255 byte sets it to 0 and decrementing a 0 byte sets is to 255.</p>
<p>Note also that the <code>+</code>s being on the first line and <code>.</code> on the second line is just to make the program easier to read. Any characters in a BF program that are not an instruction, are simply ignored by the BF program.</p>
<pre><code>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.
---
.
</code></pre>
<p>Outputs:</p>
<pre><code>he
</code></pre>
<p>Now we can finish the rest of the "hello" program!</p>
<pre><code>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.
---
.
+++++++
.
.
+++
.
</code></pre>
<p>Outputs:</p>
<pre><code>hello
</code></pre>
<h4>A useless calculator / The rest of the instructions</h4>
<p>Now, lets say we want to write a program that reads 2 digits for the user, then outputs their sum. Something like this:</p>
<pre><code>Digits to add: 23
2+3=5
</code></pre>
<p>First, we print "Digits to add: "</p>
<pre><code>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ .
+++++++++++++++++++++++++++++++++++++ .
-- .
++ .
+++++++++++ .
- .
----------------------------------------------------------------------------------- .
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ .
----- .
------------------------------------------------------------------------------- .
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ .
+++ .
 .
------------------------------------------ .
-------------------------- .
</code></pre>
<p>Once the code above has run, our memory contains the value of the last character printed and a lot of 0's: [32, 0, 0, ...].</p>
<p>Next, we read the 1st digit using the read instruction, <code>,</code>. This instruction will read a single character ant set the current byte to that value. In our example, the user enters <code>2</code> so the byte will have the value 50 = 48 + 2. Our memory looks like [50, 0, 0, ...]</p>
<p>After that, we need to read the next digit... into a different byte. For that, we use the <code>&gt;</code> instruction to go one byte to the right, then read into that byte via <code>,</code>. Once we've done that, the memory contains [50, 51, 0, 0, 0, ...]</p>
<p>Excellent! Now we can print out the <code>2+3=</code> one character at a time</p>
<ul>
<li>print out the 1st byte in memory</li>
<li>print out the '+'</li>
<li>go to the 3rd byte in memory</li>
<li>increment by the ASCII value for '+' (43)</li>
<li>print that byte</li>
<li>print out the 2nd byte in memory</li>
<li>print out the '='</li>
<li>go to the 3rd byte in memory</li>
<li>increment by difference in ASCII value for '=' (61) minus the ASCII value for '+' (61 - 43 = 18)</li>
<li>print that byte</li>
</ul>
<pre><code>&lt;.
&gt;&gt; +++++++++++++++++++++++++++++++++++++++++++ .
&lt;.
&gt; ++++++++++++++++++ .
</code></pre>
<p>Our next step is to calculate the digit we want to print. We're so close! Right now our first 2 bytes in memory have the ASCII value for the digits we want to add and what we need to compute is the ASCII value of the resulting digit. (Note: We're not going to worry about the digits adding up to more than <code>9</code> for now...)</p>
<p>For that we'll need the loop instructions, <code>[</code> which starts a loop and <code>]</code> which ends a loop. <code>[</code> will skip to the corresponding <code>]</code> instruction if the current byte is 0, otherwise the program will just run whatever code is between the <code>[</code> and <code>]</code>. Let's take some time to understand loops before we use them: The <code>]</code> will jump backwards to the corresponding <code>[</code>. The simplest loop you can write is just <code>[]</code> which will either loop infinitely or do nothing. Perhaps the next simplest loop you can write is <code>[-]</code> which will decrement the current byte until its 0 <em>or</em> maybe the next simplest loop is <code>[&gt;]</code> which will go to the next byte in memory that is 0.</p>
<p>Ok, now coming back to our task, the first 2 bytes in memory contain the ASCII values of the digits we want to add, e.g. 50 and 51. We want to calculate the ASCII value for the sum of those digits, e.g. 50-48 + 51-48 + 48 = 53. First, lets subtract 48 from both bytes in memory.</p>
<pre><code>&lt;&lt; ------------------------------------------------
&gt; ------------------------------------------------
</code></pre>
<p>Now memory looks like [2, 3, 0, 0, 0, ...].</p>
<p>Lastly, we can loop on the 2nd byte, which we'll call <code>memory[1]</code> and decrement by 1 then increment the first byte, <code>memory[0]</code>, by 1. Since the loop will execute that code until <code>memory[1]</code> is 0, it will run 3 times (or more or less if the user entered a different digit).</p>
<pre><code>[-&lt;+&gt;]
</code></pre>
<p>Now the memory looks like [5, 0, 0, 0, 0, ...].</p>
<p>Finally, we add 48 back to <code>memory[0]</code> and print it!</p>
<pre><code>&lt; ++++++++++++++++++++++++++++++++++++++++++++++++ .
</code></pre>
<p>Combining that all together, here's our full BF program:</p>
<pre><code>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ .
+++++++++++++++++++++++++++++++++++++ .
-- .
++ .
+++++++++++ .
- .
----------------------------------------------------------------------------------- .
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ .
----- .
------------------------------------------------------------------------------- .
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ .
+++ .
 .
------------------------------------------ .
-------------------------- .

,
&gt;,

&lt;.
&gt;&gt; +++++++++++++++++++++++++++++++++++++++++++ .
&lt;.
&gt; ++++++++++++++++++ .

&lt;&lt; ------------------------------------------------
&gt; ------------------------------------------------

[-&lt;+&gt;]

&lt; ++++++++++++++++++++++++++++++++++++++++++++++++ .
</code></pre>
<p>If the user enters "23", then the program outputs:</p>
<pre><code>Digits to add: 23
2+3=5
</code></pre>
<p>If the user enters "63", then the program outputs:</p>
<pre><code>Digits to add: 63
6+3=9
</code></pre>
<p>If the user enters "99", then the program outputs:</p>
<pre><code>Digits to add: 99
9+9=B
</code></pre>
<p>Perfection.</p>
<h2>Motivation</h2>
<p>Writing BF directly is quite hard, so to make it a little easier, I wanted to write code that finds/generates snippets of BF code to do an arbitrary computation.</p>
<p>For example, that we wanted to update our calculator app so that it prints "9+9=18" instead of "9+9=B". To do that, we need to be able to compute things like 'is x &gt; 10?', 'x / 10', and 'x modulo 10' where x is one of the bytes in <code>memory</code>.</p>
<h2>Where to Start</h2>
<h3>Too many BF programs to check</h3>
<p>At this point, I already knew the BF code <code>[-&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;[-&lt;+&gt;&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;]&lt;[-]</code> replaces <code>memory[0]</code> with <code>memory[0] * memory[1]</code> and sets <code>memory[1]</code> to 0. And that program is 40 instructions total, so to generate BF code that does something more complicated than multiplication, it probably needs to be able to find/generate code snippets that are around 40 instructions or more.</p>
<p>Since we're just performing computations without taking performing input or output, there are 6 instructions available. Each <code>[</code> must be paired with a <code>]</code> instruction so the number of BF programs with exactly 40 instructions is <strong>less</strong> than 5^40 = 9,094,947,017,729,282,379,150,390,625... which would only take about 5^40 / (365.25 * 24 * 60 * 60 * 4,000,000,000 * 1,000,000,000) ~= 72 years if we can check each program in 1 clock cycle on a billion 4GHz CPU cores. If you include checking all the programs that are less than 40 instructions, it only adds about 18 more years, but if you check up to 41 instruction, it takes centuries.</p>
<h3>Identical BF snippets and Registers</h3>
<p>While there may be many BF programs, most of them are probably performing the same calculation. All the following snippets just set the current byte to 1 without modifying any other bytes: <code>[[-]]+</code>, <code>[--+]+</code>, <code>[-]--&lt;&gt;+++</code>, <code>[+]++-</code>.</p>
<p>We also just want to compute simple things like <code>memory[0] * memory[1]</code> or <code>memory[0] / memory[1]</code> or <code>memory[0] &lt;= memory[1]</code>. All of these calculations take 2 bytes as input and have 1 byte as output. We might want to have more inputs or outputs but lets just stick with 2 inputs and 1 output for now.</p>
<p>At this point, there are many possible programs but also many duplicate programs.</p>
<h4>Using registers</h4>
<p>We can simplify our problem a bit by removing the <code>&gt;</code> and <code>&lt;</code> instructions and adding in an "index" or "register" that each instruction applies to. For example, instead of writing <code>[-]</code>, we could write <code>[0 -0 ]0</code> to say that the loop-start, decrement, and loop-end instructions all happen on <code>memory[0]</code>. This can help us skip bits of code that contains <code>&gt;&lt;</code> or <code>&lt;&gt;</code> <strong>and</strong> helps us just focus on BF snippets that access a limited amount of memory (which will be useful for other reasons later).</p>
<p>Rewriting BF <code>[-&gt;+&lt;]</code> to RBF (Register BF), we have <code>[0 -0 +1 ]0</code>. Similarly, rewriting our BF for multiplication <code>[-&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;[-&lt;+&gt;&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;]&lt;[-]</code>, we get <code>[0 -0 +2 ]0 [2 -2 [1 -1 +0 +3 ]1 [3 -3 +1 ]3 ]2 [1 -1 ]1</code>. Note that when we use R registers, then the number of instructions is 4 * R.</p>
<p>Now the total number of programs of length 40 instructions is dependent on the number of registers (i.e. bytes in memory) that we use. For multiplication, we needed 4 registers and we used 19 RBF instructions. To simplify again, we can pretend there's only 1 type of loop instruction to get a lower bound on the number of programs that are "similarly complex" to our multiplication program: (3 * 4) ^ 19 = 319,479,999,370,622,926,848. <strong>That's already 2.8 billion times less than our BF estimate, though it's still quite large.</strong></p>
<h3>Simplifying to 2 inputs + 1 output isn't enough</h3>
<p>So how many "unique" BF programs can there be that take 2 bytes as input and output 1 byte? There are 256^2 = 65,536 possible inputs and each of those inputs could have 256 different outputs <em>xor</em> the program can infinite loop. That's (256 + 1)^(256^2) = ... a rather large number with log(257, 10) * 256^2 ~= 157,938 digits.</p>
<p>Well... ok.</p>
<h3>What if bytes were smol?</h3>
<p>Do we really need 256 values when we're looking for instructions? There's nothing about <code>[-&gt;+&lt;]</code> that <em>really</em> depends on the number of values each byte or "cell" can hold. The same thing is true for the BF multiplication code. If we ran it on a BF machine where each cell could only go up to 10 instead of 256, the code would work essentially the same as it does now.</p>
<p>So how many unique BF programs can there be that take 2 cells as input and output 1 cell? If each cell can represent any whole number from 0 to M - 1: There are M^2 possible inputs and each of those inputs could have M different outputs <em>xor</em> infinite loop. That's (M + 1)^(M^2) total unique simple programs.</p>
<table>
<thead>
<tr>
<th>M</th>
<th>(M + 1)^(M^2)</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>81</td>
</tr>
<tr>
<td>3</td>
<td>262,144</td>
</tr>
<tr>
<td>4</td>
<td>152,587,890,625</td>
</tr>
<tr>
<td>5</td>
<td>2.84303E+19</td>
</tr>
<tr>
<td>6</td>
<td>2.65173E+30</td>
</tr>
<tr>
<td>7</td>
<td>1.78406E+44</td>
</tr>
<tr>
<td>8</td>
<td>1.17902E+61</td>
</tr>
<tr>
<td>9</td>
<td>1E+81</td>
</tr>
<tr>
<td>10</td>
<td>1.37806E+104</td>
</tr>
<tr>
<td>11</td>
<td>3.81005E+130</td>
</tr>
<tr>
<td>12</td>
<td>2.55766E+160</td>
</tr>
<tr>
<td>13</td>
<td>4.96179E+193</td>
</tr>
<tr>
<td>14</td>
<td>3.26503E+230</td>
</tr>
<tr>
<td>15</td>
<td>8.45271E+270</td>
</tr>
</tbody>
</table>
<p>Now we're talking! There's only 1 potential issue: We might need more than just 2 registers. The RBF multiplication code used 4 registers though... it assumed registers 2 and 3 started at 0 and when the code was done running, registers 2 and 3 were back to 0. We'll come back to this later...</p>
<h2>Initial Attempt</h2>
<h3>Verifying when an RBF program works</h3>
<p>First, let's make sure we can detect when a program does what we want...</p>
<pre><code class="language-python3">import dataclasses
import itertools
from typing import Literal


NUM_CELL_VALUES = 256
NUM_REGISTERS = 2
NUM_INPUT_REGISTERS = 2
NUM_OUTPUT_REGISTERS = 1


class RBFException(Exception):
    pass


class MismatchedBraces(RBFException):
    pass


class InvalidProgram(RBFException):
    pass


Instruction = tuple[Literal['+', '-', '[', ']'], int]


def get_matching_braces_dict(instructions: list[Instruction]) -&gt; dict[int, int]:
    matches = {}
    left_braces = []
    for ip, (op_code, register) in enumerate(instructions):
        if op_code == '[':
            left_braces.append((ip, register))
        elif op_code == ']':
            if not left_braces:
                raise MismatchedBraces(f'Missing left brace for right brace at {ip}: {instructions}')
            left_ip, left_register = left_braces.pop()
            if left_register != register:
                raise MismatchedBraces(
                    f'Left brace register {left_register} at {left_ip} does not match right brace register {register} '
                    f'at {ip}: {instructions}')
            matches[ip] = left_ip
            matches[left_ip] = ip
    if left_braces:
        raise MismatchedBraces(f'Missing right brace for left brace(s) at {left_braces}: {instructions}')
    return matches


@dataclasses.dataclass
class RBFProgram:
    instructions: list[Instruction]
    matching_braces: dict[int, int]

    def __init__(self, instructions: list[Instruction], matching_braces: dict[int, int]=None):
        if matching_braces is None:
            matching_braces = get_matching_braces_dict(instructions)
        for op_code, register in instructions:
            if op_code not in '+-[]' or register &lt; 0:
                raise InvalidProgram(str(instructions))
        self.instructions = instructions
        self.matching_braces = matching_braces

    def run(self, memory) -&gt; None:
        '''Run this RBF program on the memory. This WILL modify the memory.'''
        ip = 0  # instruction pointer
        while ip &lt; len(self.instructions):  # Once we've reached the end of our instructions, we're done!
            op_code, register = self.instructions[ip]
            if op_code == '+':
                memory[register] = (memory[register] + 1) % NUM_CELL_VALUES
                ip += 1
            elif op_code == '-':
                memory[register] = (memory[register] - 1) % NUM_CELL_VALUES
                ip += 1
            elif op_code == '[':
                if memory[register]:
                    ip += 1
                else:
                    ip = self.matching_braces[ip] + 1
            elif op_code == ']':
                ip = self.matching_braces[ip]

    @staticmethod
    def from_rbf_str(rbf_str: str) -&gt; 'RBFProgram':
        rbf_str = ''.join(c for c in rbf_str if c in '+-[]1234567890')
        # For now, we only support up to 10 registers
        instructions = [(op_code, int(register)) for op_code, register in zip(rbf_str[::2], rbf_str[1::2])]
        return RBFProgram(instructions)


# For now, we're trying to write a program that can find something &quot;as complex&quot; as multiplication, so we just check
# that the program can multiply 2 cells.
def program_works(program: RBFProgram) -&gt; bool:
    for a, b in itertools.product(range(NUM_CELL_VALUES), repeat=NUM_INPUT_REGISTERS):
        memory = [a, b, 0, 0]
        program.run(memory)
        if memory != [(a * b) % NUM_CELL_VALUES, 0, 0, 0]:
            return False
    return True


def main():
    multiplier = RBFProgram.from_rbf_str('[0 -0 +2 ]0 [2 -2 [1 -1 +0 +3 ]1 [3 -3 +1 ]3 ]2 [1 -1 ]1')
    assert program_works(multiplier)
    adder = RBFProgram.from_rbf_str('[1 -1 +0 ]1')
    assert not program_works(adder)


if __name__ == '__main__':
    main()
</code></pre>
<p>This works. However, it takes over a minute to run on my laptop.</p>
<h3>Speeding up how we interpret RBF</h3>
<p>I find RBF code harder to read. Let's focus take a look at the (BF version) of our multiplication program to see what can be sped up.</p>
<pre><code class="language-python3">class RBFProgram:
    ...
    def as_bf_str(self, starting_register: int=0) -&gt; str:
        bf: list[str] = []
        cur_register = starting_register
        for op_code, next_register in self.instructions:
            bf.append((next_register - cur_register) * '&gt;')
            bf.append((cur_register - next_register) * '&lt;')
            bf.append(op_code)
            cur_register = next_register
        return ''.join(bf)

multiplier = RBFProgram.from_rbf_str('[0 -0 +2 ]0 [2 -2 [1 -1 +0 +3 ]1 [3 -3 +1 ]3 ]2 [1 -1 ]1')
print(multiplier.as_bf_str(2))

# Outputs:
# &lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;[-&lt;+&gt;&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;]&lt;[-]
</code></pre>
<h4>A new paradigm</h4>
<p>There are a few patterns, we can recognize:
- <code>[-]</code> Sets <code>memory[0]</code> to 0.
- <code>[-&gt;&gt;+&lt;&lt;]</code> Adds <code>memory[0]</code> to <code>memory[2]</code> and sets <code>memory[0]</code> to 0
- <code>[-&lt;+&gt;&gt;&gt;+&lt;&lt;]</code> Destructively adds one cell to two other cells</p>
<p>If we generalize these a bit, we consider BF like <code>[-&gt;--&gt;+++&lt;&lt;]</code> (and its equivalent RBF) that don't just add one cell to another <em>but instead</em> add one cell times some constant to another; <code>memory[1] -= 2 * memory[0]</code>, <code>memory[2] += 3 * memory[0]</code>, <code>memory[0] = 0</code>.</p>
<p>Instead of each <code>RBFProgram</code> being a single Python object where the instructions control everything, let's make <code>RBFProgram</code> that are specialized and delegate to each other. This will allow us to swap out pieces of the RBF program for more optimized versions.</p>
<p>Here's the new version of <code>RBFProgram</code> before we apply any optimizations:</p>
<pre><code class="language-python3"># Note that no longer need get_matching_braces_dict

class RBFProgram:
    @abstractmethod
    def run(self, memory: list[int]) -&gt; None:
        raise NotImplementedError()

    @abstractmethod
    def instructions(self) -&gt; Iterator[Instruction]:
        raise NotImplementedError()

    def as_bf_str(self, starting_register: int=0) -&gt; str:
        bf: list[str] = []
        cur_register = starting_register
        for op_code, next_register in self.instructions():
            bf.append((next_register - cur_register) * '&gt;')
            bf.append((cur_register - next_register) * '&lt;')
            bf.append(op_code)
            cur_register = next_register
        return ''.join(bf)

    @staticmethod
    def from_rbf_str(rbf_str: str) -&gt; 'RBFProgram':
        rbf_str = ''.join(c for c in rbf_str if c in '+-[]1234567890')
        instructions = [(op_code, int(register)) for op_code, register in zip(rbf_str[::2], rbf_str[1::2])]

        programs: list[list['RBFProgram']] = [[]]
        for ip, (op_code, register) in enumerate(instructions):
            if op_code == '-':
                programs[-1].append(Increment(register, -1))
            elif op_code == '+':
                programs[-1].append(Increment(register, 1))
            elif op_code == '[':
                programs.append([])
            elif op_code == ']':
                if len(programs) &lt;= 1:
                    raise MismatchedBraces(f'Missing left brace for right brace at {ip}: {instructions}')
                inner_code = Progn.or_single_program(programs.pop())
                programs[-1].append(Loop(register, inner_code))
        if len(programs) != 1:
            raise MismatchedBraces(f'Missing right brace for left brace(s): {instructions}')
        return Progn.or_single_program(programs[0])



class Increment(RBFProgram):
    &quot;&quot;&quot;Increments a cell by ANY amount.&quot;&quot;&quot;
    def __init__(self, register: int, amount: int):
        self.register = register
        self.amount = amount

    def run(self, memory: list[int]) -&gt; None:
        memory[self.register] = (memory[self.register] + self.amount) % NUM_CELL_VALUES

    def instructions(self) -&gt; Iterator[Instruction]:
        for _ in range(self.amount):
            yield '+', self.register
        for _ in range(-self.amount):
            yield '-', self.register

    def __repr__(self):
        return f'Increment({self.register!r}, {self.amount!r})'


class Loop(RBFProgram):
    &quot;&quot;&quot;Loops until memory[self.register] != 0.&quot;&quot;&quot;
    def __init__(self, register: int, inner_code: RBFProgram):
        self.register = register
        self.inner_code = inner_code

    def run(self, memory: list[int]) -&gt; None:
        while memory[self.register]:
            self.inner_code.run(memory)

    def instructions(self) -&gt; Iterator[Instruction]:
        yield '[', self.register
        yield from self.inner_code.instructions()
        yield ']', self.register

    def __repr__(self):
        return f'Loop({self.register!r}, {self.inner_code!r})'


class Progn(RBFProgram):
    &quot;&quot;&quot;A series of RBFPrograms run in sequence.&quot;&quot;&quot;
    def __init__(self, programs: list[RBFProgram]):
        self.programs = programs

    def run(self, memory: list[int]) -&gt; None:
        for p in self.programs:
            p.run(memory)

    def instructions(self) -&gt; Iterator[Instruction]:
        for p in self.programs:
            yield from p.instructions()

    @staticmethod
    def or_single_program(programs: list[RBFProgram]) -&gt; RBFProgram:
        if len(programs) == 1:
            return programs[0]
        return Progn(programs)

    def __repr__(self):
        return f'Progn({self.programs!r})'

...

def main():
    adder = RBFProgram.from_rbf_str('[1 -1 +0 ]1')
    print(adder.as_bf_str(), '--&gt;', repr(adder))
    print()
    multiplier = RBFProgram.from_rbf_str('[0 -0 +2 ]0 [2 -2 [1 -1 +0 +3 ]1 [3 -3 +1 ]3 ]2 [1 -1 ]1')
    print(multiplier.as_bf_str(2), '--&gt;', repr(multiplier))
    print()

'''
Outputs:
&gt;[-&lt;+&gt;] --&gt; Loop(1, Progn([Increment(1, -1), Increment(0, 1)]))

&lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;[-&lt;+&gt;&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;]&lt;[-] --&gt; Progn([Loop(0, Progn([Increment(0, -1), Increment(2, 1)])), Loop(2, Progn([Increment(2, -1), Loop(1, Progn([Increment(1, -1), Increment(0, 1), Increment(3, 1)])), Loop(3, Progn([Increment(3, -1), Increment(1, 1)]))])), Loop(1, Increment(1, -1))])
'''
</code></pre>
<h4>DestructiveAdd</h4>
<p>Now, we can detect <code>Loop</code>s that only contain <code>Increment</code>s and replace them with a new DestructiveAdd class:</p>
<pre><code class="language-python3">class DestructiveAdd(RBFProgram):
    &quot;&quot;&quot;An optimized version of [-], [-&gt;+&lt;], [+&gt;++&gt;---&lt;&lt;], etc.&quot;&quot;&quot;
    def __init__(self, source_register: int, targets_and_multipliers: list[tuple[int, int]]=None):
        if targets_and_multipliers is None:
            targets_and_multipliers = []
        self.source_register = source_register
        self.targets_and_multipliers = targets_and_multipliers

    def run(self, memory: list[int]) -&gt; None:
        source_amount = memory[self.source_register]
        for register, multiplier in self.targets_and_multipliers:
            memory[register] = (memory[register] + multiplier * source_amount) % NUM_CELL_VALUES
        memory[self.source_register] = 0

    def instructions(self) -&gt; Iterator[Instruction]:
        yield '[', self.source_register
        yield '-', self.source_register
        for register, multiplier in self.targets_and_multipliers:
            for _ in range(multiplier):
                yield '+', register
            for _ in range(-multiplier):
                yield '-', register
        yield ']', self.source_register

    def __repr__(self):
        return f'DestructiveAdd({self.source_register!r}, {self.targets_and_multipliers!r})'


def simplify_to_destructive_add(original_loop: Loop, increments: list[Increment]) -&gt; RBFProgram:
    source_increments = [i for i in increments if i.register == original_loop.register]
    source_amount = sum(i.amount for i in source_increments)
    if source_amount % NUM_CELL_VALUES == 0:
        raise InfiniteLoop()
    if math.gcd(source_amount, NUM_CELL_VALUES) != 1:
        # Anytime memory[source_register] is not a multiple of source_amount, this is an infinite loop!
        # We can't optimize this... easily
        return original_loop
    if source_amount != -1 and source_amount != 1:
        # TODO: Calculate the multiplicative inverse of source_amount modulo NUM_CELL_VALUES so we optimize!
        return original_loop
    multiplicative_inverse = -source_amount  # Only true if source_amount == -1 or 1
    targets_and_amounts = collections.defaultdict(int)
    for increment in increments:
        if increment.register != original_loop.register:
            targets_and_amounts[increment.register] += multiplicative_inverse * increment.amount
            if targets_and_amounts[increment.register] == 0:
                del targets_and_amounts[increment.register]
    return DestructiveAdd(original_loop.register, sorted(targets_and_amounts.items()))


def simplified_program(program: RBFProgram) -&gt; RBFProgram:
    if isinstance(program, Progn):
        inner_programs = [simplified_program(p) for p in program.programs]
        if len(inner_programs) == 1:
            return inner_programs[0]
        if all(simplified is original for simplified, original in zip(inner_programs, program.programs)):
            return program
        else:
            return Progn.or_single_program(inner_programs)
    elif isinstance(program, Loop):
        inner_code = simplified_program(program.inner_code)
        if isinstance(inner_code, Increment):
            return simplify_to_destructive_add(program, [inner_code])
        elif isinstance(inner_code, Progn) and all(isinstance(p, Increment) for p in inner_code.programs):
            return simplify_to_destructive_add(program, inner_code.programs)
        elif inner_code is not program.inner_code:
            return Loop(program.register, inner_code)
    # Note: We can perform a lot more optimizations, but we'll start here for now.
    return program

...

def main():
    multiplier = RBFProgram.from_rbf_str('[0 -0 +2 ]0 [2 -2 [1 -1 +0 +3 ]1 [3 -3 +1 ]3 ]2 [1 -1 ]1')
    print('Original multiplier:')
    print(multiplier.as_bf_str(2))
    print(repr(multiplier))
    print()

    print('Simplified multiplier:')
    multiplier = simplified_program(multiplier)
    print(multiplier.as_bf_str(2))
    print(repr(multiplier))
    print()

    assert program_works(multiplier)

    adder = RBFProgram.from_rbf_str('[1 -1 +0 ]1')
    print('Original adder:')
    print(adder.as_bf_str())
    print(repr(adder))
    print()

    adder = simplified_program(adder)
    print('Simplified adder:')
    print(adder.as_bf_str())
    print(repr(adder))
    print()

    assert not program_works(adder)

'''
Outputs:
Original multiplier:
&lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;[-&lt;+&gt;&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;]&lt;[-]
Progn([Loop(0, Progn([Increment(0, -1), Increment(2, 1)])), Loop(2, Progn([Increment(2, -1), Loop(1, Progn([Increment(1, -1), Increment(0, 1), Increment(3, 1)])), Loop(3, Progn([Increment(3, -1), Increment(1, 1)]))])), Loop(1, Increment(1, -1))])

Simplified multiplier:
&lt;&lt;[-&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;[-&lt;+&gt;&gt;&gt;+&lt;&lt;]&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;]&lt;[-]
Progn([DestructiveAdd(0, [(2, 1)]), Loop(2, Progn([Increment(2, -1), DestructiveAdd(1, [(0, 1), (3, 1)]), DestructiveAdd(3, [(1, 1)])])), DestructiveAdd(1, [])])

Original adder:
&gt;[-&lt;+&gt;]
Loop(1, Progn([Increment(1, -1), Increment(0, 1)]))

Simplified adder:
&gt;[-&lt;+&gt;]
DestructiveAdd(1, [(0, 1)])

'''
</code></pre>
<p>Now the code runs much faster.</p>
<h2>Detecting infinite loops</h2>
<p>We know that when we generate code to evaluate, we will inevitably generate code loops infinitely. While some loops can be detected with static analysis, like the <code>raise InfiniteLoop()</code> in <code>simplify_to_destructive_add</code>, there will be infinite loops that we can only detect when we start running the program.</p>
<p>Let's walk through 3 strategies.</p>
<h3>1. Stop the program after N steps</h3>
<p>Since we know the maximum number of possible values that the memory can take on, We can let each loop of the program run for up to that many steps. Any loop that runs beyond that many steps must be looping infinitely.</p>
<p>For example: If <code>NUM_REGISTERS == 2</code> and <code>NUM_CELL_VALUES == 10</code>, then we know that any loop can loop at most <code>NUM_CELL_VALUES</code>^<code>NUM_REGISTERS</code> = 100 times <strong>unless</strong> its an infinite loop!</p>
<pre><code class="language-python3">class Loop(RBFProgram):
    ...

    def run(self, memory: list[int]) -&gt; None:
        max_iterations = NUM_CELL_VALUES**NUM_REGISTERS
        num_iterations = 0
        while memory[self.register]:
            self.inner_code.run(memory)
            num_iterations += 1
            if num_iterations &gt; max_iterations:
                raise InfiniteLoop()
</code></pre>
<p>Unfortunately this doesn't work when you have nested loops. If each loop is allowed to run <code>100</code> times and you have K nested loops, you quickly get to a billion steps for just one program.</p>
<p>Another reason this approach doesn't work is that we need to detect infinite loops faster so we don't spend a lot of time running RBF with infinite loops in it.</p>
<h3>2. Keep track of the memory you've seen before</h3>
<p>The idea here is very similar to '1. Stop the program after N steps'. Instead of keeping track of how many times each loop has run, each loop keeps track of which "memories" its seen before.</p>
<pre><code class="language-python3">
class Loop(RBFProgram):
    ...

    def run(self, memory: list[int]) -&gt; None:
        past_memories = set()
        while memory[self.register]:
            self.inner_code.run(memory)
            cur_memory = tuple(memory)
            if cur_memory in past_memories:
                raise InfiniteLoop()
            past_memories.add(cur_memory)
</code></pre>
<p>This will only run the loop <em>until</em> the memory ends up in a state we've seen before. The good news is we will detect infinite loops much sooner. The bad news is that it will use more memory and will run slower since it has to take snapshots of the memory and constantly check if we've seen that memory state before.</p>
<h3>3. Fast and Slow</h3>
<p>If you've ever heard of the "fast and slow pointers" solution to detecting loops and linked lists, then this approach will look very familiar to you.</p>
<p>I think it's easiest to imagine 2 runners racing on a trail through a forest. The runners don't know if the trail loops back on itself. One runner is twice as fast as the other runner. The runners start running at the same time from the same spot. If there's no infinite loop in the trail, then the runners will never see each other... <strong>but</strong> if there is an infinite loop, then the fast runner will eventually see the slow runner again.</p>
<pre><code class="language-python3">class Loop(RBFProgram):
    ...

    def run(self, memory: list[int]) -&gt; None:
        fast_memory = memory
        slow_memory = list(memory)  # Copy the memory

        while fast_memory[self.register]:
            self.inner_code.run(fast_memory)
            if fast_memory == slow_memory:
                raise InfiniteLoop()

            self.inner_code.run(fast_memory)
            # Note: Since fast_memory[self.register] has always been non-zero,
            #        then slow_memory[self.register] has always been non-zero.
            self.inner_code.run(slow_memory)
            if fast_memory == slow_memory:
                raise InfiniteLoop()
</code></pre>
<h3>Which is best?</h3>
<p>Probably option 3 but... it depends.</p>
<h1>TODO</h1>
<p>TODO: Write the initial code. Talk about optimizations, DFAs, path collapsing in loops, using registers that start and end at 0, etc...</p>
<h2>Other Things You May Want to Learn About</h2>
<p>Checkout <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> if you want to learn a little more about what numbers represent what (English) characters or <a href="https://en.wikipedia.org/wiki/UTF-8">Unicode and UTF-8</a> if you want to learn a lot more, including how to output emojis and non-English characters.</p>
<p>You might also enjoy learning about Turing Machines, compilers, or Common LISP.</p>
<h3>Compiling to BF</h3>
<p>While I wouldn't want to write a complicated program in BF, I <em>did/do</em> enjoy <a href="https://github.com/mikelmcdaniel/simple-lisp2bf-v2/tree/master">writing a program (in Python) that takes non-BF code in and outputs BF code</a>.</p>
<p>The following Python-like program can be compiled to BF.</p>
<pre><code class="language-python3">def print_number(x):
    if x &gt;= 100:
        print(x / 100 + '0')
    if x &gt;= 10:
        print(x / 10 % 10 + '0')
    print(x % 10 + '0')

def is_digit(c):
    '0' &lt;= c and c &lt;= '9'

def read_num():
    c = read()
    result = 0
    while is_digit(c):
        result = result * 10 + (c - '0')
        c = read()
    result

def start():
    print(&quot;Enter equation to solve (e.g. '123 / 45'): &quot;)
    a = read_num()
    op_code = read()
    read()
    b = read_num()
    print(&quot;\n&quot;)
    if op_code == '+':
        result = a + b
    elif op_code == '-':
        result = a - b
    elif op_code == '*':
        result = a * b
    elif op_code == '/':
        result = a / b
    else:
        print(&quot;Sorry! Only +, -, *, and / are supported operations but we got '&quot;, op_code, &quot;'.\n&quot;)
        exit()
    print_number(a)
    print(&quot; &quot;, op_code, &quot; &quot;)
    print_number(b)
    print(&quot; = &quot;)
    print_number(result)
    print(&quot;\n&quot;)
</code></pre>
<p>If you run that BF program and type in something like "6 * 7", it outputs:</p>
<pre><code>Enter equation to solve (e.g. '123 / 45'): 16 * 7
16 * 7 = 112
</code></pre>
<p>I think it'd take too long to do a proper write up about the compiler and the compiler's code needs to be cleaned up, tested, and documented but it works!</p>

</section>
<!-- Bootstrap core JS-->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
<!-- Core theme JS-->
<script src="https://mikelmcdaniel.github.io/static/js/bootstrap_5.1.3_clean_blog.js"></script>
</body>
</html>