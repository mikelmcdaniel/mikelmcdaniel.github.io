<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Mikel Mcdaniel">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Source Code highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <!-- MathJax -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <!-- Bootstrap core -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
  <title>Homework 02. O(log(N)) Vector</title>
</head>
<body>
<header class="d-flex flex-wrap justify-content-center py-3 mb-4 border-bottom">
  <a href="/" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none">
    <span class="fs-4">Homework 02. O(log(N)) Vector</span>
  </a>
  <ul class="nav nav-pills">
    <li class="nav-item"><a href="/blog" class="nav-link">Blog</a></li>
    <li class="nav-item"><a href="/dsaa" class="nav-link">Data Structures and Algorithms</a></li>
    <li class="nav-item"><a href="https://github.com/mikelmcdaniel/mikelmcdaniel.github.io" class="nav-link">GitHub</a></li>
    <li class="nav-item"><a href="/resume" class="nav-link">Resume</a></li>
  </ul>
</header>
<section>
  <h1 class="visually-hidden">Homework 02. O(log(N)) Vector</h1>
  
<h2>Part 1: Code</h2>
<p>std::vector is pretty cool but it has one big problem: every once in a while, push_back has to create a whole new array and copy a bunch of elements which is O(n)! Luckily, we can do better, in terms of Big-O. The goal of this homework is to write a class that <em>behaves</em> like a vector but without the O(n) push_back.</p>
<p>Whenever we run out of space, we'll still allocate an array that's twice as big as the last one but instead of copying all the old elements to it, we'll keep all the current elements where they are and store new ones in the new array until it's full. One way to implement this is to have an std::vector of arrays. If our vector is called "<code>v</code>", then <code>v[0]</code> is an array of size 2<sup>0</sup> = 1, <code>v[1]</code> would be an array of size 2<sup>1</sup> = 2, <code>v[2]</code> would have size 2<sup>2</sup> = 4, ..., <code>v[x]</code> would have a size of 2<sup>x</sup>.</p>
<p><img alt="Diagram showing examples of how to turn a single index into the 2 indices needed internally." src="index_diagram.svg" /></p>
<p>Before you start writing code, figure out how to take an index into our data structure and convert it to the index in <code>v</code>. For example, index <code>v[0]</code> corresponds to <code>arrays_[0][0]</code> and <code>v[6]</code> corresponds to <code>arrays_[2][3]</code>. Feel free to talk to anyone, especially other students, for help turning a single index in <code>v</code> into the 2 indices in <code>arrays_</code>!</p>
<h3>Starter Code</h3>
<h4>log_n_vector.h</h4>
<pre><code class="c++">#ifndef _log_n_vector_h_
#define _log_n_vector_h_

#include &lt;cmath&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
class LogNVector {
  // These member variables are suggested and not required!
  // Feel free to use change the variable names or types, as long as you
  // follow the spirit of the assignment.
  std::vector&lt;std::unique_ptr&lt;T[]&gt; &gt; arrays_;
  int size_, capacity_;
public:
  LogNVector() {
    // TODO
  }
  LogNVector(const LogNVector&amp; other) : LogNVector() {
    // TODO
  }
  LogNVector(std::initializer_list&lt;T&gt; ilist) : LogNVector() {
    // TODO
  }
  ~LogNVector() {
    // TODO
  }

  int size() const noexcept {
    // TODO
  }
  int capacity() const noexcept {
    // TODO
  }
  void push_back(const T&amp; value) {
    // TODO
  }
  const T&amp; operator[](int index) const {
    // TODO
  }
  T&amp; operator[](int index) {
    // TODO
  }
};

#endif // _log_n_vector_h_
</code></pre>

<h4>manual_test.cpp</h4>
<pre><code class="c++">#include &lt;iostream&gt;

#include &quot;log_n_vector.h&quot;

using std::cout;
using std::endl;

int main() {
  LogNVector&lt;int&gt; v = {0, 11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121};
  cout &lt;&lt; &quot;v[0] == &quot; &lt;&lt; v[0] &lt;&lt; &quot;,    &amp;v[0] == &quot; &lt;&lt; &amp;v[0] &lt;&lt; endl;
  for (int j = 1; j &lt; v.size(); ++j) {
    // All the elements in the same array should have sequential addresses.
    // For example, &amp;v[2] == &amp;v[1] + 1
    // However, there's no guarantee that &amp;v[1] == &amp;v[0] + 1.
    cout &lt;&lt; &quot;v[&quot; &lt;&lt; j &lt;&lt; &quot;] == &quot; &lt;&lt; v[j] &lt;&lt; &quot;,    &quot;
         &lt;&lt; &quot;&amp;v[&quot; &lt;&lt; j &lt;&lt; &quot;] - &amp;v[&quot; &lt;&lt; j - 1 &lt;&lt; &quot;] == &quot;
         &lt;&lt; &amp;v[j] - &amp;v[j - 1] &lt;&lt; endl;
  }
  return 0;
}
</code></pre>

<pre><strong>$</strong> <kbd>clang++ -pedantic -Wall -std=c++20 -o example log_n_vector/manual_test.cpp</kbd>
<strong>$</strong> <kbd>./example</kbd></pre>

<pre><code>v[0] == 0,    &amp;v[0] == 0x631eb0
v[1] == 11,    &amp;v[1] - &amp;v[0] == 16
v[2] == 22,    &amp;v[2] - &amp;v[1] == 1
v[3] == 33,    &amp;v[3] - &amp;v[2] == -9
v[4] == 44,    &amp;v[4] - &amp;v[3] == 1
v[5] == 55,    &amp;v[5] - &amp;v[4] == 1
v[6] == 66,    &amp;v[6] - &amp;v[5] == 1
v[7] == 77,    &amp;v[7] - &amp;v[6] == 33
v[8] == 88,    &amp;v[8] - &amp;v[7] == 1
v[9] == 99,    &amp;v[9] - &amp;v[8] == 1
v[10] == 110,    &amp;v[10] - &amp;v[9] == 1
v[11] == 121,    &amp;v[11] - &amp;v[10] == 1
</code></pre>

<h3>Submission</h3>
<p>Please submit you code at <a href="https://gradeoven.com/courses/CS%202C/assignments/02.%20LogN%20Vector">gradeoven.com/courses/CS 2C/assignments/02. LogN Vector</a></p>
<h2>Part 2: Explore log_n_vector.h</h2>
<p>The goal of this part of the assignment is to practice your skills as an engineer: think about how your code should perform in theory, check how it performs in reality, and document what you find.</p>
<h3>Requirements</h3>
<p>You're going to write a <em>short</em> PDF report about your code. The exact format is up to you!</p>
<p>Here's what I'd like you to think about when writing your report:</p>
<ul>
<li>What's the big-O of time for <code>LogNVector</code> methods?</li>
<li>What's the big-O of space for <code>LogNVector</code>?</li>
<li>How does the big-O of <code>LogNVector</code> methods compare to the equivalent methods in <code>std::vector</code> and <code>std::list</code>?</li>
<li>How does the big-O (theory) compare to performance in practice (for <code>LogNVector</code>, <code>std::vector</code>, and <code>std::list</code>)?</li>
<li>Anything else you want!</li>
</ul>
<p>You are welcome to talk about this part of the assignment with your classmates <strong>as long as you don't share log_n_vector.h code</strong>. If your conclusions are different than theirs, I'd love to hear about it.</p>
<h3>Submission</h3>
<p>Submit your report as a PDF on Canvas. If you have any supporting documents/code/etc., submit them as well.</p>

</section>
</body>
</html>