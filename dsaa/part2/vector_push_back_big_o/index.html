<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Mikel Mcdaniel">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Source Code highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <!-- MathJax -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <!-- Bootstrap core plus theme -->
  <link href="https://mikelmcdaniel.github.io/static/css/bootstrap_5.1.3_cutomized.css" rel="stylesheet" />
  <title>Amortized Analysis with Vector push_back Big-O</title>
  <style>
    @media print {
      .do-not-print {
        display: none;
        position: fixed;
        top: 0;
        visibility: hidden;
      }
    }
  </style>
</head>
<body>
<!-- Navigation-->
<nav class="do-not-print navbar navbar-expand-lg navbar-light" id="mainNav">
  <div class="container px-4 px-lg-5">
    <a class="navbar-brand" href="https://mikelmcdaniel.github.io/">Home</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ms-auto py-4 py-lg-0">
        <li class="nav-item"><a href="https://mikelmcdaniel.github.io/blog" class="nav-link px-lg-3 py-3 py-lg-4">Blog</a></li>
        <li class="nav-item"><a href="https://mikelmcdaniel.github.io/dsaa" class="nav-link px-lg-3 py-3 py-lg-4">Data Structures and Algorithms</a></li>
        <li class="nav-item"><a href="https://github.com/mikelmcdaniel" class="nav-link px-lg-3 py-3 py-lg-4">GitHub</a></li>
        <li class="nav-item"><a href="https://www.linkedin.com/in/mikel-mcdaniel-14ba74164/" class="nav-link px-lg-3 py-3 py-lg-4">LinkedIn</a></li>
        <li class="nav-item"><a href="https://mikelmcdaniel.github.io/resume" class="nav-link px-lg-3 py-3 py-lg-4">Résumé</a></li>
      </ul>
    </div>
  </div>
</nav>
<!-- Page Header-->
<header class="do-not-print masthead" style="background-image: url('https://mikelmcdaniel.github.io/static/imgs/code-background.png') ">
  <div class="container position-relative px-4 px-lg-5">
    <div class="row gx-4 gx-lg-5 justify-content-center">
      <div class="col-md-10 col-lg-8 col-xl-7">
        <div class="site-heading">
          <h1>Amortized Analysis with Vector push_back Big-O</h1>
          <span class="subheading"></span>
        </div>
      </div>
    </div>
  </div>
</header>

<section class="px-3">
  
<p><a href="https://youtu.be/2ZSro82czUw">Simple Vector (Amortized) Big-O and Timing video (37 minutes)</a></p>
<h2>push_back big-O</h2>
<p>In our <code>push_back</code> code, we only have to create a new array and copy things when the array is full. Even though a single call to <code>push_back</code> is O(n) because it will do O(n) copies, in the worst case, <code>push_back</code> is not always that bad. What's the big-O of calling <code>push_back</code> O(n) times?</p>
<p>To find out, let's look at how many copies are done when we run out of capacity. We know that since we're doubling the array each time, we first resize after 2 elements, 3 elements, 5 elements, 9 elements, 17 elements, 2^k + 1 elements, etc. Here we'll create a table showing the number of elements inserted and count up the number of copies that we have to do per resize and in the last column, we'll sum up the total number of copies done so far:</p>
<table>
<thead>
<tr>
<th align="center">size=n (smallest)</th>
<th align="center">size=n (biggest)</th>
<th align="center">capacity</th>
<th align="center">copies to resize</th>
<th align="center">total copies</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">4</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">8</td>
<td align="center">15</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">16</td>
<td align="center">31</td>
</tr>
<tr>
<td align="center">33</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">32</td>
<td align="center">63</td>
</tr>
<tr>
<td align="center">65</td>
<td align="center">128</td>
<td align="center">128</td>
<td align="center">64</td>
<td align="center">127</td>
</tr>
<tr>
<td align="center">129</td>
<td align="center">256</td>
<td align="center">256</td>
<td align="center">128</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">2^(k - 1) + 1</td>
<td align="center">2^k</td>
<td align="center">2^k</td>
<td align="center">2^(k - 1)</td>
<td align="center">2^k - 1</td>
</tr>
<tr>
<td align="center">n</td>
<td align="center">2n - 2</td>
<td align="center">2n - 2</td>
<td align="center">n - 1</td>
<td align="center">2n - 2</td>
</tr>
</tbody>
</table>
<p>The number of copies we have to do is O(n) for single <code>push_back</code> because we might have to copy the n elements we've inserted so far... but it's also O(n) to call <code>push_back</code> n times. So, if you divide the big-O of doing the operation n times by n, we get that <code>push_back</code> is <strong>amortized</strong> O(n) / n = O(1).</p>
<h2>Timing It</h2>
<p>Let's see if the theory holds up. Here we'll add an <code>ops_counter</code> to our <code>TemplateVector::push_back</code> to see if it actually scales like we expect <em>and</em> we'll run a timer to see the actual time and plot them both on a graph to see how the real running time lines up with all the operations we're counting.  </p>
<p><a href="https://mikelmcdaniel.github.io/dsaa/part2/vector_push_back_big_o/template_vector.h">template_vector.h</a><pre><code class="c++">#pragma once

template &lt;typename T&gt;
class TemplateVector {
  int capacity, size_;
  T* values;

public:
  int ops_counter;

  TemplateVector() : capacity(1), size_(0), ops_counter(0) {
    values = new T[capacity];
  }
  ~TemplateVector() {
    delete[] values;
  }

  void push_back(const T&amp; value) {
    ++ops_counter;
    if (size_ &gt;= capacity) {
      // Create a new bigger
      ops_counter += 2 * capacity + 3;
      const int new_capacity = 2 * capacity;
      T *new_lines = new T[new_capacity];
      // Copy everything to the big array
      for (int i = 0; i &lt; size_; ++i) {
        ++ops_counter;
        new_lines[i] = values[i];
      }
      // Delete old array
      ops_counter += capacity;
      delete[] values;
      // Make lines point to new array
      ops_counter += 2;
      values = new_lines;
      capacity = new_capacity;
    }
    ++ops_counter;
    values[size_] = value;
    ++ops_counter;
    ++size_;
  }

  T* begin() {
    return values; // same as &amp;strs[0]
  }

  T* end() {
    return values + size_; // same as &amp;strs[size]
  }

  T&amp; operator[](int index) {
    return values[index];
  }

  int size() {
    return size_;
  }
};</code></pre><a href="https://mikelmcdaniel.github.io/dsaa/part2/vector_push_back_big_o/vector_demo.cpp">vector_demo.cpp</a><pre><code class="c++">#include &lt;iostream&gt;  // std::cout, std::endl
#include &lt;chrono&gt;
#include &lt;vector&gt;

#include &#34;template_vector.h&#34;

using namespace std;


class SimpleTimer {
  std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time;

public:
  void start() {
    start_time = std::chrono::steady_clock::now();
  }

  // Return the number of seconds since .start() was called
  double elapsed_seconds() const {
    std::chrono::duration&lt;double&gt; diff(std::chrono::steady_clock::now() - start_time);
    return diff.count();
  }
};


int main(int argc, const char *argv[]) {
  TemplateVector&lt;int&gt; vec;
  SimpleTimer timer;
  cout &lt;&lt; &#34;n,ops_counter,elapsed_seconds&#34; &lt;&lt; endl;
  timer.start();
  for (int i = 0; i &lt; 100000; ++i) {
    vec.push_back(i);
    // Only print out one in every thousand lines so the output isn&#39;t huge
    if (i % 1000 == 0) {
      cout
          &lt;&lt; vec.size() &lt;&lt; &#34;,&#34; &lt;&lt; vec.ops_counter &lt;&lt; &#34;,&#34;
          &lt;&lt; timer.elapsed_seconds() &lt;&lt; endl;
    }
  }
  return 0;
}</code></pre>
<pre><strong>$</strong> <kbd>clang++ -pedantic -Wall -lm -std=c++20 -o vector_demo vector_demo.cpp</kbd>
</pre>
<pre><strong>$</strong> <kbd>./vector_demo</kbd></pre>
<pre><samp>n,ops_counter,elapsed_seconds
1,3,3.63e-06
1001,7145,7.7633e-05
2001,14246,0.000128121
3001,25443,0.00018089
4001,28443,0.000214596
5001,47832,0.000278797
6001,50832,0.000315277
7001,53832,0.000352775
8001,56832,0.000387745
9001,92605,0.00047594
10001,95605,0.00051313
11001,98605,0.000547805
12001,101605,0.000582669
13001,104605,0.000617049
14001,107605,0.000651477
15001,110605,0.00068565
16001,113605,0.000719567
17001,182146,0.000865872
18001,185146,0.000906084
19001,188146,0.000940781
20001,191146,0.000975057
21001,194146,0.00100948
22001,197146,0.00104365
23001,200146,0.00107779
24001,203146,0.00111229
25001,206146,0.00115005
26001,209146,0.00118448
27001,212146,0.00121848
28001,215146,0.00125295
29001,218146,0.00128762
30001,221146,0.00132178
31001,224146,0.00135557
32001,227146,0.00139178
33001,361223,0.00165275
34001,364223,0.00169401
35001,367223,0.00173043
36001,370223,0.00176455
37001,373223,0.00179835
38001,376223,0.00184064
39001,379223,0.00187594
40001,382223,0.00191007
41001,385223,0.00194414
42001,388223,0.00197802
43001,391223,0.00200978
44001,394223,0.0020432
45001,397223,0.00207725
46001,400223,0.00211143
47001,403223,0.0021454
48001,406223,0.00217935
49001,409223,0.00221598
50001,412223,0.00225047
51001,415223,0.0022842
52001,418223,0.00231822
53001,421223,0.00235266
54001,424223,0.00238681
55001,427223,0.00242134
56001,430223,0.00245518
57001,433223,0.00248921
58001,436223,0.00252363
59001,439223,0.00255825
60001,442223,0.00259652
61001,445223,0.00263051
62001,448223,0.00266492
63001,451223,0.00269896
64001,454223,0.00273475
65001,457223,0.00276911
66001,722372,0.00324282
67001,725372,0.00329012
68001,728372,0.00332584
69001,731372,0.00336106
70001,734372,0.00339587
71001,737372,0.00343116
72001,740372,0.0034678
73001,743372,0.00350564
74001,746372,0.00354103
75001,749372,0.00357593
76001,752372,0.00361082
77001,755372,0.00364602
78001,758372,0.00368122
79001,761372,0.00371618
80001,764372,0.00375112
81001,767372,0.00378837
82001,770372,0.00382386
83001,773372,0.00385888
84001,776372,0.00389384
85001,779372,0.00392919
86001,782372,0.00396211
87001,785372,0.00399666
88001,788372,0.0040321
89001,791372,0.00406727
90001,794372,0.00410194
91001,797372,0.00414106
92001,800372,0.00417663
93001,803372,0.00421191
94001,806372,0.00424687
95001,809372,0.00428169
96001,812372,0.00431847
97001,815372,0.00435554
98001,818372,0.00439107
99001,821372,0.00442619
</samp></pre>
</p>
<p><img alt="TemplateVector::push_back timing" src="vector_push_back_timing.svg" /></p>

</section>
<!-- Bootstrap core JS-->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
<!-- Core theme JS-->
<script src="https://mikelmcdaniel.github.io/static/js/bootstrap_5.1.3_clean_blog.js"></script>
</body>
</html>