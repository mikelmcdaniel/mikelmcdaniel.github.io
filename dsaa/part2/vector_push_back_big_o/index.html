<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Mikel Mcdaniel">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Source Code highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <!-- MathJax -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <!-- Bootstrap core -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
  <title>Amortized Analysis with Vector push_back Big-O</title>
</head>
<body>
<header class="d-flex flex-wrap justify-content-center py-3 mb-4 border-bottom">
  <a href="/" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none">
    <span class="fs-4">Amortized Analysis with Vector push_back Big-O</span>
  </a>
  <ul class="nav nav-pills">
    <li class="nav-item"><a href="https://mikelmcdaniel.github.io/blog" class="nav-link">Blog</a></li>
    <li class="nav-item"><a href="https://mikelmcdaniel.github.io/dsaa" class="nav-link">Data Structures and Algorithms</a></li>
    <li class="nav-item"><a href="https://github.com/mikelmcdaniel/mikelmcdaniel.github.io" class="nav-link">GitHub</a></li>
    <li class="nav-item"><a href="https://mikelmcdaniel.github.io/resume" class="nav-link">Resume</a></li>
  </ul>
</header>
<section>
  <h1 class="visually-hidden">Amortized Analysis with Vector push_back Big-O</h1>
  
<p><a href="https://youtu.be/2ZSro82czUw">Simple Vector (Amortized) Big-O and Timing video (37 minutes)</a></p>
<h2>push_back big-O</h2>
<p>In our <code>push_back</code> code, we only have to create a new array and copy things when the array is full. Even though a single call to <code>push_back</code> is O(n) because it will do O(n) copies, in the worst case, <code>push_back</code> is not always that bad. What's the big-O of calling <code>push_back</code> O(n) times?</p>
<p>To find out, let's look at how many copies are done when we run out of capacity. We know that since we're doubling the array each time, we first resize after 2 elements, 3 elements, 5 elements, 9 elements, 17 elements, 2^k + 1 elements, etc. Here we'll create a table showing the number of elements inserted and count up the number of copies that we have to do per resize and in the last column, we'll sum up the total number of copies done so far:</p>
<table>
<thead>
<tr>
<th align="center">size=n (smallest)</th>
<th align="center">size=n (biggest)</th>
<th align="center">capacity</th>
<th align="center">copies to resize</th>
<th align="center">total copies</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">4</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">8</td>
<td align="center">15</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">16</td>
<td align="center">31</td>
</tr>
<tr>
<td align="center">33</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">32</td>
<td align="center">63</td>
</tr>
<tr>
<td align="center">65</td>
<td align="center">128</td>
<td align="center">128</td>
<td align="center">64</td>
<td align="center">127</td>
</tr>
<tr>
<td align="center">129</td>
<td align="center">256</td>
<td align="center">256</td>
<td align="center">128</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">2^(k - 1) + 1</td>
<td align="center">2^k</td>
<td align="center">2^k</td>
<td align="center">2^(k - 1)</td>
<td align="center">2^k - 1</td>
</tr>
<tr>
<td align="center">n</td>
<td align="center">2n - 2</td>
<td align="center">2n - 2</td>
<td align="center">n - 1</td>
<td align="center">2n - 2</td>
</tr>
</tbody>
</table>
<p>The number of copies we have to do is O(n) for single <code>push_back</code> because we might have to copy the n elements we've inserted so far... but it's also O(n) to call <code>push_back</code> n times. So, if you divide the big-O of doing the operation n times by n, we get that <code>push_back</code> is <strong>amortized</strong> O(n) / n = O(1).</p>
<h2>Timing It</h2>
<p>Let's see if the theory holds up. Here we'll add an <code>ops_counter</code> to our <code>TemplateVector::push_back</code> to see if it actually scales like we expect <em>and</em> we'll run a timer to see the actual time and plot them both on a graph to see how the real running time lines up with all the operations we're counting.  </p>
<p><a href="https://mikelmcdaniel.github.io/dsaa/part2/vector_push_back_big_o/template_vector.h">template_vector.h</a><pre><code class="c++">#pragma once

template &lt;typename T&gt;
class TemplateVector {
  int capacity, size_;
  T* values;

public:
  int ops_counter;

  TemplateVector() : capacity(1), size_(0), ops_counter(0) {
    values = new T[capacity];
  }
  ~TemplateVector() {
    delete[] values;
  }

  void push_back(const T&amp; value) {
    ++ops_counter;
    if (size_ &gt;= capacity) {
      // Create a new bigger
      ops_counter += 2 * capacity + 3;
      const int new_capacity = 2 * capacity;
      T *new_lines = new T[new_capacity];
      // Copy everything to the big array
      for (int i = 0; i &lt; size_; ++i) {
        ++ops_counter;
        new_lines[i] = values[i];
      }
      // Delete old array
      ops_counter += capacity;
      delete[] values;
      // Make lines point to new array
      ops_counter += 2;
      values = new_lines;
      capacity = new_capacity;
    }
    ++ops_counter;
    values[size_] = value;
    ++ops_counter;
    ++size_;
  }

  T* begin() {
    return values; // same as &amp;strs[0]
  }

  T* end() {
    return values + size_; // same as &amp;strs[size]
  }

  T&amp; operator[](int index) {
    return values[index];
  }

  int size() {
    return size_;
  }
};</code></pre><a href="https://mikelmcdaniel.github.io/dsaa/part2/vector_push_back_big_o/vector_demo.cpp">vector_demo.cpp</a><pre><code class="c++">#include &lt;iostream&gt;  // std::cout, std::endl
#include &lt;chrono&gt;
#include &lt;vector&gt;

#include &#34;template_vector.h&#34;

using namespace std;


class SimpleTimer {
  std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time;

public:
  void start() {
    start_time = std::chrono::steady_clock::now();
  }

  // Return the number of seconds since .start() was called
  double elapsed_seconds() const {
    std::chrono::duration&lt;double&gt; diff(std::chrono::steady_clock::now() - start_time);
    return diff.count();
  }
};


int main(int argc, const char *argv[]) {
  TemplateVector&lt;int&gt; vec;
  SimpleTimer timer;
  cout &lt;&lt; &#34;n,ops_counter,elapsed_seconds&#34; &lt;&lt; endl;
  timer.start();
  for (int i = 0; i &lt; 100000; ++i) {
    vec.push_back(i);
    // Only print out one in every thousand lines so the output isn&#39;t huge
    if (i % 1000 == 0) {
      cout
          &lt;&lt; vec.size() &lt;&lt; &#34;,&#34; &lt;&lt; vec.ops_counter &lt;&lt; &#34;,&#34;
          &lt;&lt; timer.elapsed_seconds() &lt;&lt; endl;
    }
  }
  return 0;
}</code></pre>
<pre><strong>$</strong> <kbd>clang++ -pedantic -Wall -lm -std=c++20 -o vector_demo vector_demo.cpp</kbd>
</pre>
<pre><strong>$</strong> <kbd>./vector_demo</kbd></pre>
<pre><samp>n,ops_counter,elapsed_seconds
1,3,3.144e-06
1001,7145,4.5804e-05
2001,14246,6.5828e-05
3001,25443,8.8758e-05
4001,28443,0.000102249
5001,47832,0.000131661
6001,50832,0.00014611
7001,53832,0.000160059
8001,56832,0.000174848
9001,92605,0.00025113
10001,95605,0.000286587
11001,98605,0.000322917
12001,101605,0.000358959
13001,104605,0.000391865
14001,107605,0.000423055
15001,110605,0.000453405
16001,113605,0.000489914
17001,182146,0.000596025
18001,185146,0.000618588
19001,188146,0.000637138
20001,191146,0.000651641
21001,194146,0.000665631
22001,197146,0.000681386
23001,200146,0.000712579
24001,203146,0.00073304
25001,206146,0.000771695
26001,209146,0.000793821
27001,212146,0.000813248
28001,215146,0.000847489
29001,218146,0.000867365
30001,221146,0.000891224
31001,224146,0.000911623
32001,227146,0.000927963
33001,361223,0.0010771
34001,364223,0.00110599
35001,367223,0.00112274
36001,370223,0.00114722
37001,373223,0.00116355
38001,376223,0.00117826
39001,379223,0.00119241
40001,382223,0.0012066
41001,385223,0.00122085
42001,388223,0.00123496
43001,391223,0.00124794
44001,394223,0.00126175
45001,397223,0.00127568
46001,400223,0.00128957
47001,403223,0.0013034
48001,406223,0.00131716
49001,409223,0.00133201
50001,412223,0.00135987
51001,415223,0.0013755
52001,418223,0.00138975
53001,421223,0.00140345
54001,424223,0.00141724
55001,427223,0.00143085
56001,430223,0.00144457
57001,433223,0.00145825
58001,436223,0.0014722
59001,439223,0.00148585
60001,442223,0.00149947
61001,445223,0.00151446
62001,448223,0.00152833
63001,451223,0.00154194
64001,454223,0.00155651
65001,457223,0.0015702
66001,722372,0.00188495
67001,725372,0.00190724
68001,728372,0.00192616
69001,731372,0.0019406
70001,734372,0.00195474
71001,737372,0.00196883
72001,740372,0.00198292
73001,743372,0.00199744
74001,746372,0.00201169
75001,749372,0.00202582
76001,752372,0.00203991
77001,755372,0.00205405
78001,758372,0.00206816
79001,761372,0.00208231
80001,764372,0.00209653
81001,767372,0.00211189
82001,770372,0.00212647
83001,773372,0.00214063
84001,776372,0.00215481
85001,779372,0.00216903
86001,782372,0.00218188
87001,785372,0.00219558
88001,788372,0.00220967
89001,791372,0.00222351
90001,794372,0.00223734
91001,797372,0.00225117
92001,800372,0.00226491
93001,803372,0.00227855
94001,806372,0.00229234
95001,809372,0.00230603
96001,812372,0.00231985
97001,815372,0.00233516
98001,818372,0.00234895
99001,821372,0.00236262
</samp></pre>
</p>
<p><img alt="TemplateVector::push_back timing" src="vector_push_back_timing.svg" /></p>

</section>
</body>
</html>