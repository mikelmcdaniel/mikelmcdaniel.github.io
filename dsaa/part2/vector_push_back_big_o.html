<p><!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Mikel Mcdaniel">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Source Code highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <!-- MathJax -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <!-- Bootstrap core -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
  <title>Vector push_back Big-O</title>
</head>
<body>
<header class="d-flex flex-wrap justify-content-center py-3 mb-4 border-bottom">
  <a href="/" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none">
    <span class="fs-4">Vector push_back Big-O</span>
  </a>
  <ul class="nav nav-pills">
    <li class="nav-item"><a href="/blog" class="nav-link">Blog</a></li>
    <li class="nav-item"><a href="/dsaa" class="nav-link">Data Structures and Algorithms</a></li>
    <li class="nav-item"><a href="https://github.com/mikelmcdaniel/mikelmcdaniel.github.io" class="nav-link">GitHub</a></li>
    <li class="nav-item"><a href="/resume" class="nav-link">Resume</a></li>
  </ul>
</header>
<section>
  <h1 class="visually-hidden">Vector push_back Big-O</h1>
  </p>
<h2>push_back big-O</h2>
<p>In our <code>push_back</code> code, we only have to create a new array and copy things when the array is full. Even though a single call to <code>push_back</code> is O(n) because it will do O(n) copies, in the worst case, <code>push_back</code> is not always that bad. What's the big-O of calling <code>push_back</code> O(n) times?</p>
<p>To find out, let's look at how many copies are done when we run out of capacity. We know that since we're doubling the array each time, we first resize after 2 elements, 3 elements, 5 elements, 9 elements, 17 elements, 2^k + 1 elements, etc. Here we'll create a table showing the number of elements inserted and count up the number of copies that we have to do per resize and in the last column, we'll sum up the total number of copies done so far:</p>
<table>
<thead>
<tr>
<th align="center">size=n (smallest)</th>
<th align="center">size=n (biggest)</th>
<th align="center">capacity</th>
<th align="center">copies to resize</th>
<th align="center">total copies</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">4</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">8</td>
<td align="center">15</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">16</td>
<td align="center">31</td>
</tr>
<tr>
<td align="center">33</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">32</td>
<td align="center">63</td>
</tr>
<tr>
<td align="center">65</td>
<td align="center">128</td>
<td align="center">128</td>
<td align="center">64</td>
<td align="center">127</td>
</tr>
<tr>
<td align="center">129</td>
<td align="center">256</td>
<td align="center">256</td>
<td align="center">128</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">2^(k - 1) + 1</td>
<td align="center">2^k</td>
<td align="center">2^k</td>
<td align="center">2^(k - 1)</td>
<td align="center">2^k - 1</td>
</tr>
<tr>
<td align="center">n</td>
<td align="center">2n - 2</td>
<td align="center">2n - 2</td>
<td align="center">n - 1</td>
<td align="center">2n - 2</td>
</tr>
</tbody>
</table>
<p>The number of copies we have to do is O(n) for single <code>push_back</code> because we might have to copy the n elements we've inserted so far... but it's also O(n) to call <code>push_back</code> n times. So, if you divide the big-O of doing the operation n times by n, we get that <code>push_back</code> is <strong>amortized</strong> O(n) / n = O(1).</p>
<h2>Timing It</h2>
<p>Let's see if the theory holds up. Here we'll add an <code>ops_counter</code> to our <code>TemplateVector::push_back</code> to see if it actually scales like we expect <em>and</em> we'll run a timer to see the actual time and plot them both on a graph to see how the real running time lines up with all the operations we're counting.  </p>
<p>template_vector.h<pre><code class="c++">#pragma once

template &lt;typename T&gt;
class TemplateVector {
  int capacity, size_;
  T* values;

public:
  int ops_counter;

  TemplateVector() : capacity(1), size_(0), ops_counter(0) {
    values = new T[capacity];
  }
  ~TemplateVector() {
    delete[] values;
  }

  void push_back(const T&amp; value) {
    ++ops_counter;
    if (size_ &gt;= capacity) {
      // Create a new bigger
      ops_counter += 2 * capacity + 3;
      const int new_capacity = 2 * capacity;
      T *new_lines = new T[new_capacity];
      // Copy everything to the big array
      for (int i = 0; i &lt; size_; ++i) {
        ++ops_counter;
        new_lines[i] = values[i];
      }
      // Delete old array
      ops_counter += capacity;
      delete[] values;
      // Make lines point to new array
      ops_counter += 2;
      values = new_lines;
      capacity = new_capacity;
    }
    ++ops_counter;
    values[size_] = value;
    ++ops_counter;
    ++size_;
  }

  T* begin() {
    return values; // same as &amp;strs[0]
  }

  T* end() {
    return values + size_; // same as &amp;strs[size]
  }

  T&amp; operator[](int index) {
    return values[index];
  }

  int size() {
    return size_;
  }
};</code></pre>vector_demo.cpp<pre><code class="c++">#include &lt;iostream&gt;  // std::cout, std::endl
#include &lt;chrono&gt;
#include &lt;vector&gt;

#include &#34;template_vector.h&#34;

using namespace std;


class SimpleTimer {
  std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time;

public:
  void start() {
    start_time = std::chrono::steady_clock::now();
  }

  // Return the number of seconds since .start() was called
  double elapsed_seconds() const {
    std::chrono::duration&lt;double&gt; diff(std::chrono::steady_clock::now() - start_time);
    return diff.count();
  }
};


int main(int argc, const char *argv[]) {
  TemplateVector&lt;int&gt; vec;
  SimpleTimer timer;
  cout &lt;&lt; &#34;n,ops_counter,elapsed_seconds&#34; &lt;&lt; endl;
  timer.start();
  for (int i = 0; i &lt; 100000; ++i) {
    vec.push_back(i);
    // Only print out one in every thousand lines so the output isn&#39;t huge
    if (i % 1000 == 0) {
      cout
          &lt;&lt; vec.size() &lt;&lt; &#34;,&#34; &lt;&lt; vec.ops_counter &lt;&lt; &#34;,&#34;
          &lt;&lt; timer.elapsed_seconds() &lt;&lt; endl;
    }
  }
  return 0;
}</code></pre>
<pre><strong>$</strong> <kbd>clang -pedantic -Wall -lm -lstdc++ -std=c++20 -o vector_demo vector_demo.cpp</kbd>
</pre>
<pre><strong>$</strong> <kbd>./vector_demo</kbd></pre>
<pre><samp>n,ops_counter,elapsed_seconds
1,3,2.127e-06
1001,7145,3.1389e-05
2001,14246,4.5264e-05
3001,25443,6.2853e-05
4001,28443,7.1233e-05
5001,47832,9.5714e-05
6001,50832,0.000105609
7001,53832,0.000114341
8001,56832,0.000123239
9001,92605,0.000161016
10001,95605,0.000170522
11001,98605,0.000179145
12001,101605,0.000187723
13001,104605,0.000196317
14001,107605,0.000205919
15001,110605,0.000215661
16001,113605,0.000224197
17001,182146,0.000293394
18001,185146,0.000304306
19001,188146,0.000314026
20001,191146,0.000323727
21001,194146,0.000333234
22001,197146,0.000343054
23001,200146,0.000360903
24001,203146,0.000370506
25001,206146,0.000379947
26001,209146,0.000389325
27001,212146,0.000397731
28001,215146,0.000406966
29001,218146,0.000415245
30001,221146,0.000424589
31001,224146,0.000433984
32001,227146,0.000444336
33001,361223,0.000572878
34001,364223,0.000583074
35001,367223,0.000592385
36001,370223,0.000601601
37001,373223,0.000610853
38001,376223,0.00062012
39001,379223,0.000628376
40001,382223,0.000637727
41001,385223,0.000646992
42001,388223,0.000655197
43001,391223,0.000663538
44001,394223,0.000672798
45001,397223,0.000681968
46001,400223,0.00069121
47001,403223,0.000700533
48001,406223,0.000709747
49001,409223,0.000719856
50001,412223,0.000729595
51001,415223,0.000738855
52001,418223,0.000748051
53001,421223,0.000756295
54001,424223,0.000765394
55001,427223,0.000774539
56001,430223,0.000782794
57001,433223,0.000791989
58001,436223,0.000801287
59001,439223,0.000810555
60001,442223,0.000819732
61001,445223,0.000828995
62001,448223,0.000838201
63001,451223,0.000847419
64001,454223,0.000856402
65001,457223,0.000865668
66001,722372,0.00109692
67001,725372,0.00110798
68001,728372,0.00111633
69001,731372,0.00112471
70001,734372,0.00113298
71001,737372,0.00114271
72001,740372,0.00115185
73001,743372,0.00116018
74001,746372,0.00116955
75001,749372,0.00117778
76001,752372,0.00118708
77001,755372,0.00120591
78001,758372,0.00121559
79001,761372,0.00122501
80001,764372,0.00124377
81001,767372,0.00125408
82001,770372,0.00126336
83001,773372,0.00127266
84001,776372,0.00128206
85001,779372,0.00129142
86001,782372,0.00129973
87001,785372,0.0013091
88001,788372,0.00131846
89001,791372,0.00132772
90001,794372,0.00133697
91001,797372,0.00134633
92001,800372,0.00135569
93001,803372,0.00136488
94001,806372,0.0013741
95001,809372,0.0013824
96001,812372,0.00139169
97001,815372,0.00140176
98001,818372,0.00141006
99001,821372,0.00141984
</samp></pre>
</p>
<p><img alt="TemplateVector::push_back timing" src="vector_push_back_timing.svg" /></p>
<p>
</section>
</body>
</html>