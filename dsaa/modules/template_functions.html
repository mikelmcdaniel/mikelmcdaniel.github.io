<p><!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Mikel Mcdaniel">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Source Code highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <!-- MathJax -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <!-- Bootstrap core -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
  <title>Template Functions</title>
</head>
<body>
<header class="d-flex flex-wrap justify-content-center py-3 mb-4 border-bottom">
  <a href="/" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none">
    <span class="fs-4">Template Functions</span>
  </a>
  <ul class="nav nav-pills">
    <li class="nav-item"><a href="/blog" class="nav-link">Blog</a></li>
      <li class="nav-item"><a href="/dsaa" class="nav-link">Data Structures and Algorithms</a></li>
    <li class="nav-item"><a href="https://github.com/mikelmcdaniel/mikelmcdaniel.github.io" class="nav-link">GitHub</a></li>
  </ul>
</header>
<section>
  <h1 class="visually-hidden">Template Functions</h1>
  </p>
<h2>Template Functions</h2>
<h3>Programming without Templates</h3>
<p>Let's see what C++ programming might be like without templates, using a simple function that calculates the minimum of two things:</p>
<pre><code class="c++">#include &lt;iostream&gt;

using std::cout;
using std::endl;

int my_min(int x, int y) {
  return (x &lt; y) ? x : y;
}

int main(int argc, const char *argv[]) {
  cout &lt;&lt; my_min(2, 3) &lt;&lt; endl;
  cout &lt;&lt; my_min(5, 4) &lt;&lt; endl;
  return 0;
}
</code></pre>

<p>Well that was easy but what if I want <code>my_min</code> to also work on floating point numbers? If I called <code>my_min(2.2, 3.3)</code>, it would return <code>2</code> instead of <code>2.2</code>! Let's fix it by overloading the function:</p>
<pre><code class="c++">#include &lt;iostream&gt;

using std::cout;
using std::endl;

int my_min(int x, int y) {
  return (x &lt; y) ? x : y;
}

double my_min(double x, double y) {
  return (x &lt; y) ? x : y;
}

int main(int argc, const char *argv[]) {
  cout &lt;&lt; my_min(2, 3) &lt;&lt; endl;
  cout &lt;&lt; my_min(5, 4) &lt;&lt; endl;
  cout &lt;&lt; my_min(2.2, 3.3) &lt;&lt; endl;
  cout &lt;&lt; my_min(5.5, 4.4) &lt;&lt; endl;
  return 0;
}
</code></pre>

<p>Now this works... but it still only works for <code>int</code> and <code>double</code>. What about <code>long</code>? What about <code>std::string</code>? You could just copy and paste the code again and change the types and that will solve the problem for <code>long</code> and <code>std::string</code>. This is a bad solution to my problem: You have to copy-paste the same exact code lots of times <em>and</em> it will only work for the types that you think about. What if someone else creates a new class that's comparable and they want to use <code>my_min</code>? They would have to overload <code>my_min</code> again.</p>
<h3>Programming with Templates</h3>
<p>Ideally, we'd have some way to write <code>my_min</code> once <em>and</em> have it work for any type. BOOM! Templates.</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;

using std::cout;
using std::endl;

template&lt;typename T&gt;
T my_min(const T&amp; x, const T&amp; y) {
  return (x &lt; y) ? x : y;
}

// When you see templates, it's common to use `T` as the typename but you can
// use basically whatever name you want, like you can with variables or classes.
template&lt;typename someTYPEnaaaaame&gt;
someTYPEnaaaaame my_max(const someTYPEnaaaaame&amp; x, const someTYPEnaaaaame&amp; y) {
  return (x &gt; y) ? x : y;
}

int main(int argc, const char *argv[]) {
  string apples = &quot;apples&quot;, oranges = &quot;oranges&quot;;
  cout &lt;&lt; my_min(2, 3) &lt;&lt; endl;
  cout &lt;&lt; my_min(5, 4) &lt;&lt; endl;
  cout &lt;&lt; my_min(2.2, 3.3) &lt;&lt; endl;
  cout &lt;&lt; my_min(5.5, 4.4) &lt;&lt; endl;
  cout &lt;&lt; my_min(apples, oranges) &lt;&lt; endl;
  cout &lt;&lt; my_min(oranges, apples) &lt;&lt; endl;
  return 0;
}
</code></pre>

<p>Now <code>my_min</code> works for almost any type, as long as the less than operator is overloaded for that type (like <code>std::string</code>).</p>
<h4>Templates in Header Files</h4>
<p>If you accidentally define a function inside a header file and you include that header file more than once, your code won't compile because there will be two version of the same function and the compiler (the linker) won't know which one to use.</p>
<p>bad_my_min.h<pre><code class="c++">#pragma once
// Templates should be declared and defined in the header file.
// If they are declared in the header file and defined in the .cpp file, then
// the compiler won&#39;t know how to compile the template when it sees it being
// used in another .cpp file.
template &lt;typename T&gt;
T my_min(const T&amp; x, const T&amp; y);

// my_min should not be defined in the header file because it should only be
// defined/compiled once.
int my_max(int x, int y) {
  return (x &gt; y) ? x : y;
}

// This is correct: non-template functions should be declared but not defined in
// header files.
double my_max(double x, double y);</code></pre>bad.cpp<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;

#include &#34;bad_my_min.h&#34;

using std::cout;
using std::endl;
using std::string;

int main(int argc, const char* argv[]) {
string apples = &#34;apples&#34;, oranges = &#34;oranges&#34;;
  cout &lt;&lt; my_min(2, 3) &lt;&lt; endl;
  cout &lt;&lt; my_min(5, 4) &lt;&lt; endl;
  cout &lt;&lt; my_min(2.2, 3.3) &lt;&lt; endl;
  cout &lt;&lt; my_min(5.5, 4.4) &lt;&lt; endl;
  cout &lt;&lt; my_min(apples, oranges) &lt;&lt; endl;
  cout &lt;&lt; my_min(oranges, apples) &lt;&lt; endl;
  cout &lt;&lt; endl;
  cout &lt;&lt; my_max(100, 200) &lt;&lt; endl;
  cout &lt;&lt; my_max(111.111, 222.222) &lt;&lt; endl;
  return 0;
}</code></pre>bad_my_min.cpp<pre><code class="c++">#include &#34;bad_my_min.h&#34;

// This template function should be defined in the header file so that when the
// compiler sees this function being used, it can compile it. Since the function
// is defined in this .cpp file and it is not used in this .cpp file, this
// template is never actually used/compiled!
template &lt;typename T&gt;
T my_min(const T&amp; x, const T&amp; y) {
  return (x &lt; y) ? x : y;
}

// This is correct: my_max should be defined in the .cpp file so it&#39;s compiled
// exactly once.
double my_max(double x, double y) {
  return (x &gt; y) ? x : y;
}</code></pre>
<pre><strong>$</strong> <kbd>clang -pedantic -Wall -lm -lstdc++ -std=c++20 -o example template_example/bad.cpp template_example/bad_my_min.cpp</kbd>
<pre><samp>/usr/bin/ld: /tmp/bad_my_min-404eff.o: in function `my_max(int, int)&#39;:
bad_my_min.cpp:(.text+0x0): multiple definition of `my_max(int, int)&#39;; /tmp/bad-e1f4cc.o:bad.cpp:(.text+0x0): first defined here
/usr/bin/ld: /tmp/bad-e1f4cc.o: in function `main&#39;:
bad.cpp:(.text+0xcc): undefined reference to `int my_min&lt;int&gt;(int const&amp;, int const&amp;)&#39;
/usr/bin/ld: bad.cpp:(.text+0x124): undefined reference to `int my_min&lt;int&gt;(int const&amp;, int const&amp;)&#39;
/usr/bin/ld: bad.cpp:(.text+0x196): undefined reference to `double my_min&lt;double&gt;(double const&amp;, double const&amp;)&#39;
/usr/bin/ld: bad.cpp:(.text+0x20c): undefined reference to `double my_min&lt;double&gt;(double const&amp;, double const&amp;)&#39;
/usr/bin/ld: bad.cpp:(.text+0x261): undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; my_min&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)&#39;
/usr/bin/ld: bad.cpp:(.text+0x2b9): undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; my_min&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)&#39;
clang: error: linker command failed with exit code 1 (use -v to see invocation)
</samp></pre></pre>
</p>
<p>Behind the scenes, when the compiler sees a template function, it doesn't actually compile it right away. Since the compiler doesn't know what type <code>T</code> is until the template is used, it can't compile it until the first time it sees it being used. This means that template functions should be defined in the header file, so that any file that includes the header can see the full template.</p>
<p>good_my_min.h<pre><code class="c++">#pragma once

template &lt;typename T&gt;
T my_min(const T&amp; x, const T&amp; y) {
  return (x &lt; y) ? x : y;
}

int my_max(int x, int y);
double my_max(double x, double y);</code></pre>good.cpp<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;

#include &#34;good_my_min.h&#34;

using std::cout;
using std::endl;
using std::string;

int main(int argc, const char* argv[]) {
string apples = &#34;apples&#34;, oranges = &#34;oranges&#34;;
  cout &lt;&lt; my_min(2, 3) &lt;&lt; endl;
  cout &lt;&lt; my_min(5, 4) &lt;&lt; endl;
  cout &lt;&lt; my_min(2.2, 3.3) &lt;&lt; endl;
  cout &lt;&lt; my_min(5.5, 4.4) &lt;&lt; endl;
  cout &lt;&lt; my_min(apples, oranges) &lt;&lt; endl;
  cout &lt;&lt; my_min(oranges, apples) &lt;&lt; endl;
  cout &lt;&lt; endl;
  cout &lt;&lt; my_max(100, 200) &lt;&lt; endl;
  cout &lt;&lt; my_max(111.111, 222.222) &lt;&lt; endl;
  return 0;
}</code></pre>good_my_min.cpp<pre><code class="c++">#include &#34;good_my_min.h&#34;

int my_max(int x, int y) {
  return (x &gt; y) ? x : y;
}

double my_max(double x, double y) {
  return (x &gt; y) ? x : y;
}</code></pre>
<pre><strong>$</strong> <kbd>clang -pedantic -Wall -lm -lstdc++ -std=c++20 -o example template_example/good.cpp template_example/good_my_min.cpp</kbd>
</pre>
<pre><strong>$</strong> <kbd>./example</kbd></pre>
<pre><samp>2
4
2.2
4.4
apples
apples

200
222.222
</samp></pre></p>
<p>
</section>
</body>
</html>