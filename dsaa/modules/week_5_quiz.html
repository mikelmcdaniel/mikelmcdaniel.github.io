<p><!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Mikel Mcdaniel">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Source Code highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <!-- MathJax -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <!-- Bootstrap core -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
  <title>Week 5 Quiz Answers</title>
</head>
<body>
<header class="d-flex flex-wrap justify-content-center py-3 mb-4 border-bottom">
  <a href="/" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none">
    <span class="fs-4">Week 5 Quiz Answers</span>
  </a>
  <ul class="nav nav-pills">
    <li class="nav-item"><a href="/blog" class="nav-link">Blog</a></li>
      <li class="nav-item"><a href="/dsaa" class="nav-link">Data Structures and Algorithms</a></li>
    <li class="nav-item"><a href="https://github.com/mikelmcdaniel/mikelmcdaniel.github.io" class="nav-link">GitHub</a></li>
  </ul>
</header>
<section>
  <h1 class="visually-hidden">Week 5 Quiz Answers</h1>
  </p>
<h2>Week 5 Quiz Answers</h2>
<p>Email me, post in the Canvas Discussions, or come to office hours if you have any questions.</p>
<p>NOTE: I'll be out of town Tuesday-Thursday with very little internet access. I've made the quiz due Thursday (instead of Tuesday) to give you extra time but please try to send me questions before Tuesday!</p>
<h3>1. AVL Tree heights</h3>
<p>For each N below, what's the minimum and maximum possible height of an AVL tree with N nodes?</p>
<table>
<thead>
<tr>
<th>N</th>
<th>min height</th>
<th>max height</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>7</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>42</td>
<td></td>
<td></td>
</tr>
<tr>
<td>123</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>987654321</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4>Answer</h4>
<table>
<thead>
<tr>
<th>N</th>
<th>min height</th>
<th>max height</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>7</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>42</td>
<td>5</td>
<td>7</td>
</tr>
<tr>
<td>123</td>
<td>7</td>
<td>9</td>
</tr>
<tr>
<td>1000</td>
<td>10</td>
<td>14</td>
</tr>
<tr>
<td>987654321</td>
<td>30</td>
<td>42</td>
</tr>
<tr>
<td>N</td>
<td>ceil(log2(N + 1))</td>
<td>ceil(fib^-1(N + 1))</td>
</tr>
</tbody>
</table>
<h3>2. Valid AVL Tree</h3>
<p>Write a function that takes a <code>Node *</code> (see code below) pointing to the root of an AVL Tree as input and returns <code>true</code> if it's a valid AVL Tree and <code>false</code> if it is not.</p>
<pre><code class="c++">template &lt; typename Key, typename Value&gt;
class Node {
private:
  // ...

public:
  Node *left();
  Node *right();
  const Key&amp; key() const;
  const Value&amp; value() const;
  const int balance_factor() const;
};
</code></pre>

<h4>Answer</h4>
<pre><code class="c++">#include &lt;cmath&gt;

using std::max;

template &lt;typename Key, typename Value&gt;
int height(Node&lt;Key, Value&gt;* root) {
  if (root == nullptr) {
    return 0;
  } else {
    return 1 + max(height&lt;Key, Value&gt;(root-&gt;left()), height&lt;Key, Value&gt;(root-&gt;right()));
  }
}

template &lt;typename Key, typename Value&gt;
bool is_valid_avl_tree(Node&lt;Key, Value&gt;* root, const Key&amp; lower_bound, const Key&amp; upper_bound) {
  if (root == nullptr) {
    return true;
  }
  if (
      root-&gt;balance_factor() &lt; -1 || root-&gt;balance_factor() &gt; 1 ||
      root-&gt;balance_factor() != height&lt;Key, Value&gt;(root-&gt;right()) - height&lt;Key, Value&gt;(root-&gt;left()) ||
      root-&gt;key() &lt; lower_bound || root-&gt;key() &gt; upper_bound) {
    return false;
  }
  return (
      is_valid_avl_tree&lt;Key, Value&gt;(root-&gt;left(), lower_bound, root-&gt;key()) &amp;&amp;
      is_valid_avl_tree&lt;Key, Value&gt;(root-&gt;right(), root-&gt;key(), upper_bound));
}

template &lt; typename Key, typename Value&gt;
bool is_valid_avl_tree(Node&lt;Key, Value&gt;* root) {
  if (root == nullptr) {
    return true;
  }
  // Get smallest node
  auto min_node = root;
  for(; min_node-&gt;left() != nullptr; min_node = min_node-&gt;left());
  Node&lt;Key, Value&gt;* max_node;
  for(max_node = root; max_node-&gt;right() != nullptr; max_node = max_node-&gt;right());
  return is_valid_avl_tree&lt;Key, Value&gt;(root, min_node-&gt;key(), max_node-&gt;key());
}
</code></pre>

<h3>3. AVL Tree Height</h3>
<p>Write a function that takes a <code>Node *root</code> (see code below) and returns the height of the tree in O(log(n)) time.</p>
<pre><code class="c++">template &lt;typename Key, typename Value&gt;
class Node {
private:
  // ...

public:
  Node *left();
  Node *right();
  const Key&amp; key() const;
  const Value&amp; value() const;
  const int balance_factor() const;
};
</code></pre>

<h4>Answer</h4>
<pre><code class="c++">template &lt;typename Key, typename Value&gt;
int height(Node&lt;Key, Value&gt;* root) {
  if (root == nullptr) {
    return 0;
  } else {
    return 1 + height&lt;Key, Value&gt;(
        root-&gt;balance_factor() &lt; 0 ? root-&gt;left() : root-&gt;right());
  }
}
</code></pre>

<h3>4. O(no)</h3>
<p>What's the big-O of erasing from a balanced binary search tree in terms of N, the number of elements in the tree?</p>
<h4>Answer</h4>
<p>O(log(N))</p>
<h3>5. Better BST Iterators (part 1)</h3>
<p>The Binary Search Tree Iterators from the class lectures could be a little better. What's the big-O of <code>operator!=</code>?</p>
<pre><code class="c++">class Iterator {
  vector&lt;Node*&gt; stack;
public:
  // constructor
  Iterator() {}
  Iterator(Node* root) {
    for (Node* cur = root; cur != nullptr; cur = cur-&gt;left) {
      stack.push_back(cur);
    }
  }
  // compare (!=)
  bool operator!=(const Iterator&amp; rhs) const {
    return stack != rhs.stack;
  }
  // dereference (*)
  pair&lt;Key, Value&gt; operator*() const {
    Node* top = stack.back();
    return pair&lt;Key, Value&gt;(top-&gt;key, top-&gt;value);
  }
  // increment (++)
  Iterator&amp; operator++() {
    Node* cur = stack.back()-&gt;right;
    stack.pop_back();
    for (; cur != nullptr; cur = cur-&gt;left) {
      stack.push_back(cur);
    }
    return *this;
  }
};
</code></pre>

<h4>Answer</h4>
<p>O(height(...)) == O(N) for an unbalanced binary search tree.</p>
<h3>6. Better BST Iterators (part 2)</h3>
<p>Rewrite <code>operator!=</code>, from the last question, so that it is O(1).</p>
<h4>Answer</h4>
<pre><code class="c++">bool operator==(const Iterator&amp; rhs) const {
  return
      (stack.empty() &amp;&amp; rhs.stack.empty()) ||
      (!stack.empty() &amp;&amp; !rhs.stack.empty() &amp;&amp;
          stack.back() == rhs.stack.back());
}

bool operator!=(const Iterator&amp; rhs) const {
  return
      (stack.empty() != rhs.stack.empty()) ||
      (!stack.empty() &amp;&amp; !rhs.stack.empty() &amp;&amp;
      stack.back() != rhs.stack.back());
}
</code></pre>

<h3>7. AVL Tree Manual Insert</h3>
<p>What would the AVL Tree below look like after inserting 'm'?
What would the new AVL Tree (with 'm' in it) look like after inserting 'n'?</p>
<p>Note: It's not enough to just make a new tree that's balanced. You need to think about exactly how an AVL Tree would rebalance the tree after inserting!</p>
<pre><code>  b
 / \
a   z
   /
  y
</code></pre>

<h4>Answer</h4>
<p>Inserting m:</p>
<pre><code>  b
 / \
a   y
   / \
  m   z
</code></pre>

<p>Inserting n:</p>
<pre><code>    m
   / \
  b   y
 /   / \
a   n   z
</code></pre>

<h3>Favorite</h3>
<p>What lecture video was your favorite and why?</p>
<h4>Answer</h4>
<p>It's hard to choose which child is your favorite.</p>
<p>
</section>
</body>
</html>